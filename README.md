- 👋 Hi, I’m @lukitooo15
- 👀 I’m interested in ...
- 🌱 I’m currently learning ...
- 💞️ I’m looking to collaborate on ...
- 📫 How to reach me ...

<!---
lukitooo15/lukitooo15 is a ✨ special ✨ repository because its `README.md` (this file) appears on your GitHub profile.
You can click the Preview link to take a look at your changes.
--->
# Python Syntax

print("Hello, World!")


# Python Indentation
# პითონი იყენებს ჩაღრმავებას, რათა მიუთითოს კოდის ბლოკი მაგ:

if 5 > 2:
  print("Five is greater than two!")

# Pyhton - ი error - ს მოგვცემს თუ სინტაქსს არ დავიცავთ მაგ:

#if 5 > 2:
#print("Five is greater than two!")

# გარკვეული სივრცის დატოვება ჩვენზეა დამოკიდებული მაგ:

if 5 > 2:
 print("Five is greater than two!")  
if 5 > 2:
        print("Five is greater than two!") 

# უნდა გამოვიყენო იგივე რაოდენობის სივრცეები კოდის იმავე ბლოკში თორე Pyhton - ი error - ს მოგვცემს მაგ:

#if 5 > 2:
# print("Five is greater than two!") 
#        print("Five is greater than two!")


# Pyhton ცვლადები (Variables)
# Pyhton - ში ცვლადები მაშინ იქმნება როცა მას მნიშვნელობას ვანიჭებთ მაგ:

a = 5
z = "Hello, World!"

print(a)
print(z)

# პითონს არ აქვს ცვლადის გამოცხადების ბრძანება


# კომენტარები (comments)
# კომენტარები იწყება # - ით ხოლო Python ხაზს გამოიტანს როგორც კომენტარი მაგ:

#This is a comment.
print("Hello, World!")


# Python Comments
# კომენტარი შეიძლება გამოყენებული იქნას რაღაც კოდის ასახსნელად
# კომენტარი შეიძლება გამოყენებული იქნას კოდის უფრო მარტივად წასაკითხად
# კომენტარის გამოყენება შეიძლება კოდის დატესტვისას

# კომენტარის შექმნა (Creating a Comment)
# კომენტარები იწყება # - ით და Pyhton - ი მას უბრალოდ იგნორს გაუკეთებს მაგ:

#This is a comment.
print("Hello, World!")

# კომენტარები შეიძლება განთავსდეს სტრიქონის ბოლოს და Python - ი მას უბრალოდ იგნორს გაუკეთებს მაგ:

print("Hello, World!") #This is a comment

# კომენტარი არ უნდა იყოს ტექსტი რომელიც ხსნის კოდს ის ასევე შეიძლება გამოყენებული იქნას პითონის კოდის შესრულების თავიდან ასაცილებლად მაგ:

# მრავალხაზოვანი კომენტარები
# პითონს ნამდვილად არ აქვს სინტაქსი მრავალხაზოვანი კომენტარებისთვის
# მრავალხაზოვანი კომენტარის დასამატებლად შემიძლია ჩავსვა # თითოეული ხაზისთვის მაგ:

#This is a comment
#written in
#more than just one line
print("Hello, World!")

# ასევე შეგვიძლია გამოვიყენოთ მრავალხაზოვანი სტრიქონი მაგ:

"""
This is a comment
written in
more than just one line
"""
print("Hello, World!")


# Python Variables
# ცვლადი არის კონტეინერი მონაცემთა ტიპის შესანახად

# Creating Variables
# პითონს არ აქვს ცვლადის გამოცხადების ბრძანება
# ცვლადი მაშინ იქმნება როცა მას რაღაც მნიშვნელობას ვანიჭებთ მაგ:

a = 5
z = "Beki"
print(a)
print(z)

# ცვლადს შეიძლება ტიპი შეუცვალოთ მაგ:

x = 5       # x is of type int
x = "Beki" # x is now of type str
print(x)


# Casting
# თუ ცვლადის მონაცემის ტიპის მითითება მინდა შემიძლია გამოვიყენო casting - ი მაგ:

a = str(3)    # x will be '3'
y = int(3)    # y will be 3
z = float(3)  # z will be 3.0

print(a)
print(y)
print(z)


# Get the Type
# იმისთვის რო ცვლადის მონაცემთა ტიპი გავიგო უნდა გამოვიყენო type() ფუნქცია მაგ:

a = 5
z = "Beki"
print(type(a))
print(type(z))

# ერთმაგი თუ ორმაგი ბრჭყალები?
# str ცვლადი შეიძლება გამოყენებილი იქნას ერთმაგი ან ორმაგი ბრჭყალების გამოყენებით მაგ:

a = "Beki"
print(a)

# ორმაგ და ერთმაგ ბრჭყალებს ერთი და იგივე მნიშვნელობა აქვს 

a = 'Beki'
print(x)


# Case-Sensitive
# ცვლადების სახელები case-sensitive - ია მაგ:

a = 5
A = "Beki"

print(a)
print(A)


# Python - Variable Names (ცვლადების სახელები)
# ცვლადს შეიძლება ჰქონდეს მოკლე სახელი (მაგ: a ან z) ან უფრო აღწერითი სახელი (ასაკი გვარი წელი)
# ცვლადის სახელი უნდა იწყებოდეს ასოთი ან ქვედა ხაზით
# ცვლადის სახელი არ შეიძლება დაიწყოს რიცხვით
# ცვლადის სახელი შეიძლება შეიცავდეს მხოლოდ ალფა-ციფრულ სიმბოლოებს და ქვედა ხაზებს (A-z, 0-9 და _ )
# ცვლადის სახელები მგრძნობიარეა რეგისტრის მიმართ (age Age და AGE სამი განსხვავებული ცვლადია)
# ცვლადის სახელი არ შეიძლება იყოს პითონის რომელიმე საკვანძო სიტყვა მაგ:

myvar = "Beki"
my_var = "Beki"
_my_var = "Beki"
myVar = "Beki"
MYVAR = "Beki"
myvar2 = "Beki"


print(myvar)
print(my_var)
print(_my_var)
print(myVar)
print(MYVAR)
print(myvar2)

# შეცდომით დაწერილი ცვლადის სახელები მაგ:

# 2myvar = "Beki"
# my-var = "Beki"
# my var = "Beki"

# ამის შემდეგ Pyhton - ი მოგვცემს error - ს
# ცვლადის სახელი მგრძნობიარეა

# მრავალსიტყვიანი ცვლადის სახელები 
# ცვლადის სახელები ერთზე მეტი სიტყვით შეიძლება იყოს რთული წასაკითხი 
# არსებობს რამდენიმე ტექნიკა რომელთა გამოყენებაც აადვილებს კოდის წაკითხვას მაგ:

# Camel Case
# თითოეული სიტყვა გარდა პირველისა იწყება დიდი ასოებით მაგ:

myVariableName = "Beki"

# Pascal Case
# თითოეული სიტყვა იწყება დიდი ასოთი მაგ:

MyVariableName = "Beki"

# Snake Case
#თითოეული სიტყვა გამოყოფილია ხაზგასმული სიმბოლოთი მაგ:

my_variable_name = "Beki"


# Pyhton - ის ცვლადები მრავალი მნიშვნელობის მინიჭება
# მრავალი მნიშვნელობები მრავალ ცვლადზე
# პითონი საშუალებას მაძლევს მივანიჭო მნიშვნელობები მრავალ ცვლადს ერთ ხაზზე მაგ:

a, y, z = "Orange", "Banana", "Cherry"

print(a)
print(y)
print(z)

# უდნა დავრწმუნდე რო ცვლადების რაოდენობა ცვლადების რაოდენობა მნიშვნელობების რაოდენობას ემთხვევა წინააღმდეგ თორე Pyhton - ი error - ს მოგვცემს

# ერთი მნიშვნელობა მრავალ ცვლადზე
# ასევე შემიძლია იგივე მნიშვნელობა მივანიჭო მრავალ ცვლადს ერთ ხაზზე მაგ:

a = y = z = "Orange"

print(a)
print(y)
print(z)


# კოლექიის "განყუთვა"
# თუ მაქვს მნიშვნელობების კოლექცია სიაში, ტუპლში და ა.შ. Python - ი  მაძლევს საშუალებას ამოვიღო მნიშვნელობები ცვლადებად ამას ჰქვია "განყუთვა" მაგ:

fruits = ["apple", "banana", "cherry"]
a, y, z = fruits

print(a)
print(y)
print(z)


# Python - Output Variables
# Pyhton - ის print() ფუნქცია გამოიყენება ცვადების გამოსატანად მაგ:

a = "Python is awesome"
print(a)

# print() ფუნქციაში გამომყავს რამდენიმე ცვლადი გამოყოფილი მძიმით მაგ:

a = "Python"
y = "is"
z = "awesome"
print(a, y, z)

# ასევე შეიძლება გამოვიყენო "+"" ოპერატორი მრავალი ცვლადის გამოსატანად მაგ:

a = "Python "
y = "is "
z = "awesome"
print(a + y + z)

# "Python" - ის და "is" - ის შემდეგ space - ი რო არა შედეგი იქნება "Pythonisawesome"
# რიცხვებისთვის "+"" სიმბოლო მუშაობს როგორც მათემატიკური ოპერატორი მაგ:

a = 5
z = 10
print(a + z)

# print() ფუნქციაში როცა string - ის და number - ის გაერთიანება გვინდა "+" ოპერატორით Pyhton - ი მოგვცემს error - ს მაგ:

#a = 5
#y = "Beki"
#print(a + y)

# print() ფუნქციაში მრავალი ცვლადის გამოსატანად საუკეთესო გზა მათი მძიმეებით გამოყოფაა მაგ:

a = 5
z = "Beki"

print(a, z)




# Pyhton - გლობალური ცვლადები
# ცვლადი რომელიც იქმნება ფუნქციის მიღმა ცნობილია როგორც გლობალური ცვლადი
# გლოაბლური ცვლადები შეიძლება გამოყენებული იქნას ყველასგან როგორც ფუნქციის შიგნით ასევე მის გარეთ მაგ:

a = "awesome"

def myfunc():
  print("Python is " + a)

myfunc()

# თუ შევქმნი ცვლადს იგივე სახელით ფუნქციის შიგნით ეს ცვლადი იქნება ლოკალური და გამოყენება შესაძელებელი
# იქნება მხოლოდ ფუნქციის შიგნით გლობალური ცვლადი იგივე სახელით დარჩება როგორც იყო გლობალური და ორიგინალური მნიშვნელობით მაგ:

x = "awesome"

def myfunc():
  x = "fantastic"
  print("Python is " + x)

myfunc()

print("Python is " + x)


# გლობალური საკვანძო სიტყვა
# ჩვეულებრივ როცა ვქმნი ცვლადს ფუნქციის შიგნით ეს ცვლადი ლოკალურია და მისი გამოყენება შესაძლებელია მხოლოდ ამ ფუნქციის შიგნით
# იმისთვის რო შევქმნათ გლობალური ცვლადი ფუნქციის შიგნით უნდა გამოვიყენოთ global საკვანძო სიტყვა მაგ:

def myfunc():
  global x
  x = "fantastic"

myfunc()

print("Python is " + x)

# ასევე შეგვიძლია გამოვიყენოთ გლობალური საკვანძო სიტყვა თუ გლობალური ცვლადის შეცვლა მინდა ფუნქციის შიგნით მაგ:

a = "awesome"

def myfunc():
  global a
  a = "fantastic"

myfunc()

print("Python is " + a)


# Python - მონაცემთა ტიპები
# ჩაშენებული მონაცემთა ტიპები
# პროგრამირებაში მონაცემთა ტიპი მნიშვნელოვანი რამა არის
# ცვლადებს შეუძლიათ შეინახონ სხვადასხვა ტიპის მონაცემები, ხოლო სხვადასხვა ტიპებს შეუძლიათ სხვადასხვა რამის გაკეთება
# პითონს აქვს ნაგულისხმევად ჩაშენებული მონაცემთა შემდეგი ტიპები ამ კატეგორიებში მაგ:

# ტექსტის ტიპი:   str

# რიცხვითი ტიპი: int, float, complex

# თანმიმდევრობის ტიპი: list, tuple, range

# რუკების ტიპი: dict

# კომპლექტების ტიპი: set, frozenset

# ბულის ტიპი: bool

# ბინარული ტიპი: bytes, bytearray, memoryview

# არცერთი ტიპი: NoneType


# მონაცემთა ტიპის შეგროვება
# შემიძლია მივიღო ნებისმიერი ობიექტის მონაცემთა ტიპი type() ფუნქციის გამოყენებით მაგ:

a = 3
print(type(a))


# მონაცემთა ტიპის დაყენება
# Pyhton - ში მონაცემთა ტიპი მაშინ დგინდება როცა ცვლადს რაღაც მნიშვნელობას ვანიჭებ მაგ:

# მაგალითი                                                                  მონაცემთა ტიპი

# a = "Hello World"                                                              str

# a = 20                                                                         int

# a = 20.5                                                                       float

# a = 1j                                                                         complex

# a = ["apple", "banana", "cherry"]                                              list

# a = ("apple", "banana", "cherry")                                              tuple

# a = range(6)                                                                   range

# a = {"name" : "John", "age" : 36}                                              dict

# a = {"apple", "banana", "cherry"}                                              set

# a = frozenset({"apple", "banana", "cherry"})                                   frozenset

# a = True                                                                        bool

# a = b"Hello"                                                                    bytes

# a = bytearray(5)                                                                byterray

# a = memoryview(bytes(5))                                                       memoryview

# a = None                                                                       memoryview

# კონკრეტული მონაცემთა ტიპის დაყენება
# თუ მონაცემთა ტიპის მოთითება მინდა შემიძლია გამოვიყენო შემდეგი კონსტრუქტორის ფუნქციები:

# მაგალითი                                                                  მონაცემთა ტიპი

# a = str("Hello World")                                                              str

# a = int(20)                                                                         int

# a = float(20.5)                                                                    float

# a = complex(1j)                                                                     complex

# a = list(("apple", "banana", "cherry"))                                              list

# a = tuple(("apple", "banana", "cherry"))                                            tuple

# a = range(6)                                                                         range

# a = dict(name="John", age=36)                                                         dict

# a = set(("apple", "banana", "cherry"))                                                set

# a = frozenset(("apple", "banana", "cherry"))                                       frozenset

# a = bool(5)                                                                           bool

# a = bytes(5)                                                                        bytes

# a = bytearray(5)                                                                    byterray

# a = memoryview(bytes(5))                                                              memoryview

# a = None                                                                         


# Python Numbers
# პითონში არის სამი რიცხვითი ტიპი ესენია:

int
float
complex

# რიცხვითი ტიპების ცვლადები მაშინ იქმნება როცა მათ მნიშვნელობას ვანიჭებ მაგ:

x = 1    # int
y = 2.8  # float
z = 1j   # complex

# იმისთვის რო ნებისმიერი ობიექტის მონაცემთა ტიპი შევამოწმოთ უნდა გამოვიყენოთ type() ფუნქცია მაგ:

a = 1
y = 2.8
z = 1j

print(type(a))
print(type(y))
print(type(z))

x = 1
y = 2.8
z = 1j

print(type(x))
print(type(y))
print(type(z))


# Int
# Int ანუ მთელი რიცხვი არის მთელი რიცხვი დადებითი ან უარყოფითი ათწილადების გარეშე შეუზღუდავი სიგრძით მაგ:

x = 1
y = 35656222554887711
z = -3255522

print(type(x))
print(type(y))
print(type(z))

# Float
# Float ან "მცურავი წერტილის ნომერი" არის რიცხვი დადებითი ან უარყოფითი რომელიც შეიცავს ერთ ან მეტ ათწილადს მაგ:

x = 1.10
y = 1.0
z = -35.59

print(type(x))
print(type(y))
print(type(z))

# Float ასევე შეიძლება იყოს სამეცნიერო რიცხვები მაგ: "e"-თი აღნიშნული და ა.შ მაგ:

x = 35e3
y = 12E4
z = -87.7e100

print(type(x))
print(type(y))
print(type(z))

# Complex
# რთული რიცხვები იწერება "j"-თი როგორც წარმოსახვითი ნაწილი მაგ:

x = 3+5j
y = 5j
z = -5j

print(type(x))
print(type(y))
print(type(z))

# ტიპის კონვერტაცია
# შემიძლია ერთი ტიპიდან მეორეზე გადავიყვანო int() float() და complex() მეთოდების გამოყენებით მაგ:

a = 1    # int
y = 2.8  # float
z = 1j   # complex


# გადავიყვანო int - დან float - ში:
x = float(1)

# გადავიყვანო int - დან float - ში
y = int(2.8)

# გადავიყვანო int - დან complex - ში
z = complex(1)

print(a)
print(y)
print(z)

print(type(x))
print(type(y))
print(type(z))

# რთული რიცხვების სხვა ტიპად გადაქცევა შეუძლებელია


# Random Number
# პითონს არ აქვს random() ფუნქცია შემთხვევითი რიცხვის შესაქმნელად მაგრამ პითონს აქვს ჩაშენებული მოდული
# რომელსაც ეწოდება random რომელიც შეიძლება გამოყენებულ იქნას შემთხვევითი რიცხვების შესაქმნელად მაგ:

import random

print(random.randrange(1, 10))


# Python Casting
# ცვლადის ტიპის მითითება
# შეიძლება იყოს შემთხვევები როდესაც მინდა რო ცვლადის ტიპი მიუთითო ეს შეიძლება გაკეთდეს კასტინგით პითონი არის ობიექტზე ორიენტირებული ენა ამიტომ იყენებს კლასებს მონაცემთა ტიპების მათ შორის მისი პრიმიტიული ტიპების დასადგენად მაგ:
# ამიტომ პითონში კასტინგი ხდება კონსტრუქტორის ფუნქციების გამოყენებით 
# int() - აშენებს მთელ რიცხვს მთელი ლიტერალიდან float ლიტერალიდან ან სტრიქონის ლიტერალიდან
# float() - აშენებს float რიცხვს მთელი ლიტერალიდან float ლიტერალიდან ან სტრიქონის ლიტერალიდან
# str() - აყალიბებს სტრიქონს მონაცემთა სხვადასხვა ტიპებიდან მათ შორის სტრიქონები მთელი რიცხვები და float ლიტერალები მაგ:

a = int(1) # a იქნება 1
y = int(2.8) # y იქნება 2
z = int("3") # z იქნება 3

print(a)
print(y)
print(z)

a = float(1)     # a იქნება 1.0
y = float(2.8)   # y იქნება 2.8
z = float("3")   # z იქნება 3.0
w = float("3.2") # w იქნება 3.2


print(x)
print(y)
print(z)
print(w)


a = str("s1") # a იქნება "s1"
y = str(2)    # y იქნება "2"
z = str(3.0)  # z იქნება # "3.0"

print(a)
print(y)
print(z)


# Python Strings
# Pyhton - ში str - ი ჩაწერილია ან ერთმაგ ბრჭყალებში ან ორმაგში 
# "hello" და 'hello' იგივეა მაგ:

print("Hello")
print('Hello')

# სტრიქონის მინიჭება ცვლადზე
# ცვლადისთვის სტრიქონის მინიჭება ხდება ცვლადის სახელით რასაც მოჰყვება "=" - ის  ნიშანი და სტრიქონი მაგ:

a = "Hello"
print(a)


# მრავალხაზოვანი სიმები
# მრავალხაზოვანი სტრიქონის მინიჭება ცვლადის მიმართ შემიძლია სამი ციტატის გამოყენებით მაგ:

a = """Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."""
print(a)


# ან სამი ერთმაგი ბრჭყალი

a = '''Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua.'''

print(a)

# შედეგად წყვეტილი ხაზები ჩასმულია იმავე პოზიციაზე როგორც კოდში

# სტრიქონები არის მასივები
# მრავალი სხვა პოპულარული პროგრამირების ენის მსგავსად პითონში სტრიქონები არის ბაიტების მასივები რომლებიც წარმოადგენენ უნიკოდის სიმბოლოებს
# ამასთან პითონს არ აქვს სიმბოლოების მონაცემთა ტიპი ერთი სიმბოლო უბრალოდ არის 1 სიგრძის სტრიქონი
# კვადრატული ფრჩხილები შეიძლება გამოყენებული იქნას სტრიქონის ელემენტებზე წვდომისთვის მაგ:

a = "Hello World"

print(a[1])


# Looping Through a String
# ვინაიდან სტრიქონები არის მასივები ჩვენ შეგვიძლია "გადავხედოთ" ელემენტებს for loop - ის გამოყენებით მაგ:

for a in "banana":
  print(a) 


# String Length
# იმისთვის რო სტრიქონის სირგძე გავიგოთ უნდა გამოვიყენოთ len() ფუნქცია მაგ:

a = "Hello, World!"
print(len(a))


# სტრიქონის შემოწმება
# იმის შესამოწმებლად არის თუ არა გარკვეული ფრაზა ან სიმბოლო სტრიქონში უნდა გამოვიყენო საკვვანძო სიტყვა in მაგ:

txt = "The best things in life are free!"
print("free" in txt)

# ასევე შეგვიძლია გამოვიყენოთ if განცხადება მაგ:

txt = "The best things in life are free!"
if "free" in txt:
  print("Yes, 'free' is present.")


# Check if NOT
# იმის შესამოწმებლად არის თუ არა გარკვეული ფრაზა ან სიმბოლო სტრიქონში შემიძლია გამოვიყენო საკვანძო სიტყვა not in მაგ:

txt = "The best things in life are free!"
print("expensive" not in txt)

# ასევე შემიძლია გამოვიყენო if განცხადება მაგ:

txt = "The best things in life are free!"
if "expensive" not in txt:
  print("No, 'expensive' is NOT present.")


# Pyhton - სტრიქონების "დაჭრა"
# შემიძლია დავაბრუნო ელემენტების სიგრძე slice სინტაქსის გამოყენებით
# უნდა მიუთითო საწყისი ინდექსი და ბოლო ელემენტის ინდექსი რომლებიც ორწერტილით იქნება გამოყოფილი სტრიქონის რაღაც ნაწილის დასაბრუნებლად მაგ:

a = "Hello, World!"
print(a[2:5])

# პირველ ელემენტს აქვს ინდექსი 0

# Slice From the Start
# საწყისი ინდექსის გამოტოვებით დიაპაზონი დაიწყება პირველი ელემენტიდან მაგ:

a = "Hello, World!"
print(a[:5])


# Slice To the End
# საბოლოო ინდექსის გამოტოვებით დიაპაზონი ბოლომდე დაიბეჭდება მაგ:

a = "Hello, World!"
print(a[2:])


# ნეგატიური ინდექსირება
# უნდა გამოვიყენო უარყოფითი ინდექსები იმისთვის რო სტრიქონის ბოლოდან "დაჭრა" დაივწო მაგ:

a = "Hello, World!"
print(a[-5:-2])


# Pyhton - სტრიქონების შეცვლა
# პითონს აქვს ჩაშენებული მეთოდების ნაკრები რომელიც შემიძლია გამოვიყენო სტრიქონებზე

# Upper Case


a = "Hello, World!"
print(a.upper())


# Lower Case

a = "Hello, World!"
print(a.lower())


# Remove Whitespace 
# Whitespace არის სივრცე სტრიქონებს შორის ანუ (Spacebar)
# იმისთვის რო Whitespace წავშალოთ უნდა გამოვიყენოთ strip() ფუნქცია მაგ:

a = " Hello, World! "
print(a.strip()) # returns "Hello, World!"


# Replace String
# თუ მინდა რო სტრიქონი სხვა სტრიქონით შევცვალოთ უნდა გამოვიყენოთ replace() მეთოდი მაგ:

a = "Hello, World!"
print(a.replace("H", "J"))


# სტრიქონის "გაყოფა"
# split() მეთოდი აბრუნებს სიას სადაც მითითებულ გამყოფებს შორის გამყოფი ხდება სიის ელემენტი მაგ:

a = "Hello, World!"
b = a.split(",")
print(b)


# Pyhton - სტრიქონების გაერთანება
# იმისთვის რო სტრიქონები გავაერთიანო შემიძლია გამოვიყენო "+" ოპერატორი მაგ:

a = "Hello"
b = "World"
z = a + b
print(z)

# ან შემიძლია ესეც გავაკეთო

a = "Hello"
b = "World"
z = a + " " + b
print(z)


# Python - Format - Strings
# როგორც პითონის ცვლადების დასაწყისში ვისწავლე სტრიქონების და რიცხვების გაერთიანება არ შემიძლია მაგ:

#age = 39
#txt = "My name is Beki, I am " + age
#print(txt)

# იმისთვის რო სტრიქონები და რიცხვები გავაერთიანო შემიძლია გამოვიყენო format() მეთოდი
# format() მეთოდი იღებს გადაცემულ არგუმენტებს აფორმებს მათ და ათავსებს სტრიქონში სადაც ადგილისდამკავებლები {} არიან მაგ:

age = 39
txt = "My name is Beki, and I am {}"
print(txt.format(age))

# format() მეთოდი იღებს არგუმენტების შეუზღუდავ რაოდენობას რომელიც მოთავსებულია შესაბამის placeholder - ში მაგ:

quantity = 3
itemno = 367
price = 49.95
myorder = "I want {} pieces of item {} for {} dollars."
print(myorder.format(quantity, itemno, price)) 

# შემიძლია გამოვიყენო ინდექსის ნომრები {0} რათა დავრწმუნდე რომ არგუმენტები განთავსებულია სწორ placeholder - ში მაგ:

quantity = 3
itemno = 367
price = 49.95
myorder = "I want to pay {2} dollars for {0} pieces of item {1}."
print(myorder.format(quantity, itemno, price)) 


# Python - Escape Characters
# სტრიქონში არალეგალური სიმბოლოების ჩასასმელად უნდა გამოვიყენო escape characters
# escape characters არის "\" რომელსაც ის სიმბოლო მოჰყვება რომლის ჩასმაც გვინდა 
# არალეგალური სიმბოლოს მაგალითია ორმაგი ბრჭყალები სტრიქონის შიგნით რომელიც ჩასმულია ორმაგ ბრჭყალებში მაგ:

#txt = "We are the so-called "Vikings" from the north."

# აქ დაიბეჭდება error - ი რადგან ორმაგ ბრჭყალებში ჩავწერეთ ორმაგი ბრჭყალები

# იმისთვის რო Pyhton - მა error - ი არ დაბეჭდოს უნდა გამოვიყენო \" მაგ:

txt = "We are the so-called \"Vikings\" from the north"
print(txt) 

# Escape Characters
# პითონში გამოყენებული სხვა escape characters - ი მაგ:

# კოდი                               შედეგი

# \'                                  ერთმაგი ბრჭყალი

# \\                                   უკანახაზი

# \n                                    ახალი ხაზი

# \r                                    "ვაგონის" დაბრუნება

# \t	                                      Tab

# \b	                                   Backspace

# \f                                     	Form Feed

# \ooo                                    ოქტალური მნიშვნელობა

# \xhh                                     Hex მნიშვნელობა


# Python - სტრიქონის მეთოდები
# პითონს აქვს ჩაშენებული მეთოდების ნაკრები რომელიც შემიძლია გამოვიყენო სტრიქონებზე
# სტრიქონების ყველა მეთოდი აბრუნებს ახალ მნიშვნელობებს ისინი არ ცვლიან ორიგინალურ სტრიქონს მაგ:

# მეთოდი                                           დასახელება

# capitalize()                                       სიტყვის პირველ ასოს გარდაქმნის დიდ ასოდ

# casefold()                                          სტრიქონის ყველა სიტყვებს აპატარავებს

# center()                                            აბრუნებს ცენტრირებულ სტრიქონს

# count()                                            აბრუნებს სასურველი სიტყვის აღებულ მნიშვნელობას წინადადებაში 

# encode()                                             აბრუნებს სტრიქონის დაშიფრულ ვერსიას

# format()                                            აფორმატებს მითითებულ მნიშვნელობებს სტრიქონში

# index()                                              ეძებს სტრიქონის მითითებულ მნიშვნელობას და აბრუნებს იმ ადგილს სადაც ის იქნა ნაპოვნი

# islower()                                            აბრუნებს True - ს თუ წინადადებაში ყველა ელემენტი პატარა ასოიანია

# isupper()                                            აბრუნებს True - ს თუ წინადადებაში ყველა ელემენტი დიდ ასოიანია 

# lower()                                              ელემენტის ყველა ასოს აპატარავებს

# replace()                                           აბრუნებს სტრიქონს სადაც მითითებული მნიშვნელობა შეიცვლება მითითებული მნიშვნელობით

# split()                                              ყოფს სტრიქონს მითითებულ გამყოფზე და აბრუნებს სიას             

# swapcase()                                           ცვლის ასოებს პატარა ხდება დიდი და პირიქით

# upper()                                               სიტყვის ყველა ასოს ადიდებს

# zfill()                                              ავსებს სტრიქონს დასაწყისში იმდენი ნულით რამდენსაც დავწერთ    


# Python Booleans
# booleans წარმოადგენს ორიდან ერთ-ერთ მნიშვნელობას : True ან Flase

# Boolean Values
# პროგრამირებისას ხშირად დამჭირდება იმის ცოდნა გამონათქვამი არის თუ არა True თუ False
# Pyhton - ში შემიძლია ნებისმიერი გამონათქვამი შევაფასო და მივიღო ორი პასუხი ერთი სწორი მეორე არასწორი
# როცა ვადარებ ორ მნიშვნელობას Pyhton - ი აბრუნებს ლოგიკურ პასუხს მაგ:

print(10 > 9)
print(10 == 9)
print(10 < 9)

# როდესაც ვაწარმოებ პირობას if განაცხადში Pyhton აბრუნებს ან True - ს ან False - ს მაგ:

a = 200
b = 33

if b > a:
  print("b is greater than a")
else:
  print("b is not greater than a")


# ცვლადების და ღირებულებების შეფასება
# bool() ფუნქცია საშუალებას მაძლევს შევაფასო ნებისმიერი მნიშვნელობა და სანაცვლოდ დამიბრუნოს ან True ან False მაგ:\

print(bool("Hello"))
print(bool(39))


x = "Hello"
y = 15

print(bool(x))
print(bool(y))


# ცვლადების უმეტესობა True - ა
# თითქმის ნებისმიერი მნიშვნელობაა True თუ მას აქვს რაიმე სახის შინაარსი
# ნებისმიერი სტრიქონი არის True გარდა ცარიელი სტრიქონებისა
# ნებისმიერი რიცხვი True - ა გარდა 0-ისა
# ნებისმიერი სია ტუპლი სეტი და ლექსიკონი არის True გარდა ცარიელისა მაგ:

print(bool("abc"))
print(bool(123))
print(bool(["apple", "cherry", "banana"]))

# ზოგი ცვლადი False - ა
# სინამდვილეში არ არის ბევრი მნიშვნელობა რომელიც შეიძლება რო False იყოს გარდა ცარიელი მნიშვნელობებისა როგორიცაა: (), [], {}, "", რიცხვი 0 და None და რა თქმა უნდა, მნიშვნელობა False ფასდება False - ად მაგ:

print(bool(False))
print(bool(None))
print(bool(0))
print(bool(""))
print(bool(()))
print(bool([]))
print(bool({}))

# კიდევ ერთი მნიშვნელობა ან ობიექტი ამ შემთხვევაში ფასდება False-ზე და ეს იმ შემთხვევაში თუ მაქვს ობიექტი რომელიც დამზადებულია კლასიდან __len__ ფუნქციით რომელიც აბრუნებს 0-ს ან False-ს მაგ:

class myclass():
  def __len__(self):
    return 0

myobj = myclass()
print(bool(myobj))

# ფუნქციას შეუძლია დააბრუნოს ლოგიკური მნიშვნელიბა 
# შემიძლია შევქმნა ფუნქციები რომლებიც დააბრუნებს ლოგიკურ მნიშვნელობას მაგ:

def myFunction() :
  return True

print(myFunction())

# შემიძლია შევასრულო კოდი ფუნქციის ლოგიკური პასუხის საფუძველზე მაგ:

def myfunc():
  return True

if myfunc():
  print("Yes")
else:
  print("Nope")

# Pyhton - ს ასევე აქვს მრავალი ჩაშენებული ფუნქცია რომელიც აბრუნებს ლოგიკურ მნიშვნელობას როგორიცაა isinstance() ფუნქცია რომელიც შეიძლება გამოყენებული იქნას იმის გასაგებად არის თუ არა ობიექტი მონაცემთა გარკვეული ტიპის მაგ:

a = 200
print(isinstance(a, str))


# Pyhton ოპერატორები
# ოპერატორები გამოიყენება ცვლადებსა და მნიშვნელობებზე ოპერაციების შესასრულებლად
# ქვემოთ მოცემულ მაგალითში ვიყენებ "+"" ოპერატორს ორი მნიშვნელობის დასამატებლად მაგ:

print(3 + 6)

# Pyhton - ი ოპერატორებს ანაწილებს შემდეგ ჯგუფებად:

# არითმეტიკული ოპერატორები

# დავალების ოპერატორები

# შედარების ოპერატორები

# ლოგიკური ოპერატორები

# პირადობის ოპერატორები

# წევრობის ოპერატორები

# ბიტიური ოპერატორები



# Pyhton - არითმეტიკული ოპერატორები
# არითმეტიკული ოპერატორები გამოიყენება რიცხვითი მნიშვნელობებით საერთო მათემატიკური ოპერაციების შესასრულებლად მაგ:

# ოპერატორი                                სახელი                                 მაგალითი

#   +                                        მიმატება                                a + z

#   -                                        გამოკლება                               a - z

#   *                                        გამრავლება                               a * z

#   /                                        გაყოფა                                   a / z

#   %                                        მოდული                                 a % z

#   **                                        კვადრატში აყვანა                        a ** z

#   //                                         სართული განყოფილება                  a // z


# Pyhton - დავალების ოპერატორები
# დავალების ოპერატორები გამოიყენება ცვლადებისთვის მნიშვნელობების მინიჭებისთვის მაგ:

# ოპერატორი                                        მაგალითი                                 იგივეა რაც 

#   =                                                x = 5                                   x = 5

#   +=                                               x += 3	                                 x = x + 3

#   -=                                               x -= 3	                                 x = x - 3

#   *=                                               x *= 3                                  	x = x * 3

#   /=                                               x /= 3                                  x = x / 3

#   %=                                                x %= 3                                 x = x % 3            

#   //=                                              x //= 3                                 x = x // 3

#   **=                                              x **= 3                                 x = x ** 3

#   &=                                               	x &= 3                                 x = x & 3

#   |=                                               x |= 3                                   x = x | 3

#   ^=                                                	x ^= 3                               x = x ^ 3

#   >>=                                                	x >>= 3                               x = x >> 3

#   <<=                                                x <<= 3                                x = x << 3


# Pyhton - შედარების ოპერატორები
# შედარების ოპერატორები გამოიყენება ორი მნიშვნელობის შესადარებლად მაგ:

# ოპერატორი                                სახელი                                 მაგალითი

#   ==                                       ტოლია                                a == z

#   !=                                        არ უდრის                            x != y

#   >                                        მეტია                                  a > z

#   <                                        ნაკლებია                               a < z

#   >=                                        მეტია ან ტოლი                        a >= z

#   <==                                       ნაკლებია ან ტოლი                     a <= z


# Pyhton  ლოგიკური ოპერატორები
# ლოგიკური ოპერატორები გამოიყენება პირბიითი განცხადებების გაერთიანებისთვის მაგ:

# ოპერატორი                                დასახელება                                 მაგალითი

#   and                             აბრუნებს True - ს თუ ორივე                        a < 3 and a < 6
#                                         განცხადება მართალია
#                                               არ უდრის                           

#   or                              აბრუნებს True - ს თუ რომელიმე                     a < 3 or a < 6
#                                        განცხადება True - ა


#   not                              ამ შემთხვევაში შედეგი შემობრუნდება
#                                    ანუ თუ დაბრუნდება False ანუ  შედეგი მართალია        not(x < 3 and x < 6)
#                                    ხოლო თუ დაბრუნდა True პირიქით                


# Pyhton პირადობის ოპერატორები
# პირადობის ოპერატორები გამოიყენება ობიექტების შესადარებლად არა თუ ისინი ტოლია არამედ თუ ისინი რეალურად ერთი და იგივე ობიექტია მეხსიერების იგივე მდებარეობით მაგ:

# ოპერატორი                                დასახელება                                 მაგალითი

#   is                             აბრუნებს True - ს თუ ორივე  ცვლადი                   a is z
#                                         ერთი და იგივე ობიექტია
#                                                                         

# is not                          აბრუნებს True - ს თუ ორივე ოპერატორი 
#                                   არ არის ერთი და იგივე ობიექტი


# Pyhton პირადობის ოპერატორები
# წევრობის ოპერატორები გამოიყენება იმის შესამოწმებლად არის თუ არა თანმიმდევრობა წარმოდგენილი ობიექტში მაგ:

# ოპერატორი                                დასახელება                                          მაგალითი

#   in                             აბრუნებს True - ს თუ მითითებული მნიშვნელობის            x in y
#                                       თანმიმდევრობა იმყოფება ობიექტში                                            

# not in                          აბრუნებს True - ს თუ მითითებული მნიშვნელობის               x not in y
#                                       თანმიმდევრობა არ არის ობიექტში


# Pyhton ბიტურიოპერატორები
# ბიტური ოპერატორები გამოიყენება (ორობითი) რიცხვების შესადარებლად მაგ:

# ოპერატორი            სახელი                   დასახელება                           მაგალითი

#   &                   AND                   აყენებს თითოეულ ბიტს 1 - ზე                 a & z
#                                             თუ ორივე ბიტი არის 1

#   |                   OR                    აყენებს თითოეულ ბიტს 1 - ზე თუ              a | z
#                                              ორი ბიტიდან ერთი არის 1  

#   ^                    XOR                  აყენებს თითოეულ ბიტს 1 - ზე თუ ორი           a ^ z
#                                                   ბიტიდან მხოლოდ ერთია 1

#   ~                    NOT                   აბრუნებს ყველა ბიტს                             ~x

#   <<              ნულოვანი შევსება მარცხნივ        უნდა გადავახვიო მარცხნივ მარჯვნიდან ნულების შეყვანით        x << 2
#                                                      და ნება უნდა მივცე ყველაზე მარცხნივ ჩავარდეს  

#   >>            Signed right shift	                  უნდა გადავახვიო მარჯვნივ მარცხენა ბიტის ასლების 
#                                                       მარცხნიდან დაჭერით და ნება უნდა მივცე ყველაზე მარჯვენა ბიტი ჩამივარდეს   x >> 3


# ოპერატორის უპირატესობა
# ოპერატორის უპირატესობა აღწერს ოპერაციების შესრულების თანმიმდევრობას მაგ:

print((6 + 3) - (6 + 3))

print(100 + 3 * 3)

# უპირატესობის თანმიმდევრობა აღწერილია ქვემოთ მოცემულ ცხრილში დაწყებული
#  ყველაზე მაღალი უპირატესობით ზემოთ მაგ:
# ოპერატორი                                                       დასახელება

#  ()                                                            ფრჩხილები

#   **                                                       კვადრატში აყვანა

#   +x  -x  ~x                                      Unary plus unary minus and bitwise NOT

#   *  /  //  %                               გამრავლება გაყოფა სართულებად დაყოფა და მოდულები

#   +  -                                                   შეკრება და გამოკლება

#   <<  >>                                      ბიტალურად მოძრაობს მარცხნივ და მარჯვნივ

#   &                                                        ბიტური AND

#   ^                                                       ბიტური XOR   

# ==  !=  >  >=  <  <=  is  is not  in  not in              შედარება ვინაობა და წევრობის ოპერატორები  

# not                                                          ლოგიკური არა

# and                                                            და

# or                                                              ან

# თუ ორ ოპერატორს აქვს ერთი და იგივე პრიორიტეტი მაგალითი ფასდება მარცხნიდან მარჯვნივ მაგ:

print(5 + 3 - 7 + 3)


# Pyhton სიები

mylist = ["apple", "banana", "cherry"]

# სიები გამოიყენება რამდენიმე ელემენტის ერთ ცვლადში შესანახად
# სიები არის ერთ-ერთი 4 ჩაშენებული მონაცემთა ტიპიდან ერთ-ერთი რომელიც გამოიყენება მონაცემთა კოლექციების შესანახად დანარჩენი 3 არის ტუპლი სეტი და ლექსიკონი ყველა განსხვავებული ხარისხისა და გამოყენების
# სიები იქმნება კვადრატული ფრჩხილების გამოყენებით მაგ:

thislist = ["apple", "banana", "cherry"]
print(thislist)

# სიის ელემენტები
# სიის ელემენტები დალაგებულია ცვალებადია და ნებადართულია დუბლიკატების ქონა
# სიის ელემენტები ინდექსირებულია მაგ: პირველ ელემენტს აქვს ინდექსი 0 მეორე ელემენტს აქვს ინდექსი 1 და ა.შ

# დალაგებული
# როდესაც ვამბობ რო სია დალაგებულია ეს ნიშნავს რომ ნივთებს აქვთ განსაზღვრული თანმიმდევრობა და ეს თანმიმდევრობა არ შეიცვლება
# თუ სიას ახალ ელემენტებს დავამატებ ახალი ელემენტები სიის ბოლოს განთავსდება
# არსებობს სიის რამდენიმე მეთოდი რომელიც შეცვლის თანმიმდევრობას მაგრამ ზოგადად: ნივთების თანმიმდევრობა არ შეიცვლება

# ცვალებადი
# სია ცვალებადია რაც იმას ნიშნავს რომ შემიძლია შევცვალო დავამატოთ და წავშალო ელემენტები სიაში მისი შექმნის შემდეგ

# Allow Duplicates
# ვინაიდან სიები ინდექსირებულია სიებს შეიძლება ჰქონდეთ იგივე მნიშვნელობის ელემენტები მაგ:

thislist = ["apple", "banana", "cherry", "apple", "cherry"]

print("This list")

# სიის სიგრძე
# იმისთვის რო სიის სიგრძე გავიგო უნდა გამოვიყენო len() ფუნქცია მაგ:

thislist = ["apple", "banana", "cherry"]
print(len(thislist))


# სიის ელემენტები - მონაცემთა ტიპები
# სიის ელემენტები შეიძლება იყოს ნებისმიერი მონაცემთა ტიპის მაგ:

list1 = ["apple", "banana", "cherry"]
list2 = [1, 5, 7, 9, 3]
list3 = [True, False, False]

print(list1)
print(list2)
print(list3)

# სია შეიძლება შეიცავდეს მონაცემთა სხვადასხვა ტიპებს ,აგ:

list1 = ["abc", 600, True, 39, "male"]

# type()
# Pyhton - ის პერსპექტივიდან სიები განისაზღვრება როგორც ობიექტები მონაცემთა ტიპის 'list' მაგ:

#<class: 'list'>

# მაგ:

mylist = ["apple", "banana", "cherry"]

print(type(mylist))

# list() კონსტრუქტორი
# შემიძლია გამოვიყენო list() კონსტრუქტორი ახალი სიის შესაქმნელად მაგ:

thislist = list(("apple", "banana", "cherry"))
print(thislist)

# პითონის კოლექციები (მასივები)
# Pyhton - ის პროგრამირების ენაში არსებობს მონაცემთა შეგროვების ოთხი ტიპი მაგ:

# სია არის კოლექცია რომელიც დალაგებულია ცვალებადია და ნებადართულია დუპლიკატები
# Tuple არის დალაგებული უცვლელი და ნებადართულია დუპლიკატები
# სეტი არის კოლექცია რომელიც არის დაულაგებელი უცვლელი არაინდექსირებული და ნებადართული არ არის დუპლიკატები
# ლექსიკონი არის კოლექცია რომელიც დალაგებულია ცვალებადი და ნებადართული არ არის დუპლიკატები
# კოლექციის ტიპის არჩევისას სასარგებლოა ამ ტიპის თვისებების გაგება კონკრეტული მონაცემთა ნაკრებისთვის სწორი ტიპის არჩევა შეიძლება ნიშნავდეს მნიშვნელობის შენარჩუნებას და ეს შეიძლება ნიშნავს ეფექტურობის ან უსაფრთხოების გაზრდას 


# Python - წვდომა სიის ელემენტებზე
# სიის ელემენტები ინდექსირებულია და მათზე წვდომა შემიძლია ინდექსის ნომრის მითითებით მაგ:

thislist = ["apple", "banana", "cherry"]
print(thislist[1])

# პირველ ელემენტს აქვს ინდექსი 0

# ნეგატიური ინდექსირება# ნეგატიური ინდექსირება ნიშნავს ბოლოდან დაწყებას
# -1 შეესაბამება პირველ ელემენტს -2 მეორეს და ა.შ მაგ:

thislist = ["apple", "banana", "cherry"]
print(thislist[-1])

# ინდექსის სიგრძე
# შემიძლია მიუთითო ინდექსების სიგრძე იმის მითითებით თუ სად უნდა დაიწყოს და სად დასრულდეს დიაპაზონი
# სიგრძე მითითებისას დაბრუნებული ცვლადი იქნება ახალი სია მითითებული ელემენტებით მაგ:

thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]
print(thislist[2:5])

# დაბეჭვდა დაიწყება ინდექსი 2 - ით (შედის) და დასრულდება ინდექსი 5-ით (არ შედის)
# საწყისი მნიშვნელობის გამოტოვებით დიაპაზონის დაბეჭვდა დაიწყება პირველი ელემენტიდან მაგ:

thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]
print(thislist[:3])

# ბოლო მნიშვნელობის გამოტოვებით დიაპაზონი დაიბეჭდება სიის ბოლომდე მაგ:

thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]
print(thislist[2:])

# უარყოფითი ინდექსების სიგრძე
# უნდა მიუთითო უარყოფითი ინდექსები თუ მინდა რო ძებნა სიის ბოლოდან დავიწყო მაგ:

thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]

print(thislist[-5 : -1])


# Check if Item Exists
# უნდა გამოვიყენო საკვანძო სიტყვა in იმისთვის რო გავიგო არის თუ არა მითითებული ელემენტი სიაში მაგ:

thislist = ["apple", "banana", "cherry"]
if "apple" in thislist:
  print("Yes, 'apple' is in the fruits list")


# Pyhton - სიის ელემენტების შეცვლა
# ელემენტის მნიშვნელობის შეცვლა
# კონკრეტული ელემენტის მნიშვნელობის შესაცვლელად უნდა ვიცოდე ამ ელემენტის ინდექსი მაგ:

thislist = ["apple", "banana", "cherry"]
thislist[1] = "blackcurrant"
print(thislist)

# ელემენტის მნიშვნელობების დიაპაზონის შეცვლა
# ერთეულების მნიშვნელობის შესაცვლელად კონკრეტულ დიაპაზონში, უნდა განვსაზღვრო სია ახალი მნიშვნელობებით და უდნა მივმართო ინდექსის ნომრების დიაპაზონს სადაც მსურს ახალი ელემენტების ჩასმა მაგ:

thislist = ["apple", "banana", "cherry", "orange", "kiwi", "mango"]
thislist[1:3] = ["blackcurrant", "watermelon"]
print(thislist)


# თუ ჩავსვავ უფრო მეტ ელემენტს ვიდრე ჩაანაცვლებთ ახალი ერთეულები ჩასმული იქნება იქ სადაც მიუთითებ ხოლო დანარჩენი ელემენტები შესაბამისად გადაადგილდებიან მაგ:

thislist = ["apple", "banana", "cherry"]
thislist[1:2] = ["blackcurrant", "watermelon"]
print(thislist)


# სიის სიგრძე შეიცვლება როდესაც ჩასმული ელემენტების რაოდენობა არ ემთხვევა ჩანაცვლებულ ელემენტთა რაოდენობას 

# თუ ჩავსვავ იმაზე ნაკლებ ელემენტს ვიდრე ჩავანაცვლებ ახალი ელემენტები ჩასმული იქნება იქ სადაც მიუთითე ხოლო დანარჩენი ელემენტები შესაბამისად გადაადგილდებიან მაგ:

thislist = ["apple", "banana", "cherry"]
thislist[1:3] = ["watermelon"]
print(thislist)

# ელეემნტების ჩასმა
# იმისთვის რო ახალი ელემენტი ჩავსავ სიაში სხვა ელემენტების ჩანაცვლების გარეშე შემიძლია გამოვიყენო insert() მეთოდი მაგ:

thislist = ["apple", "banana", "cherry", "blackcurrant", "peanut", "zebra"]
thislist.insert(1, "watermelon")
print(thislist)


# Python - სიის ელემენტების დამატება
# იმისთვის რო სიაში ელემენტები დავამატო უნდა გამოვიყენო append() ფუნქცია მაგ:

thislist = ["apple", "banana", "cherry", "pinguin", "globus", "watermelon"]
thislist.append("orange")
print(thislist)


# ელემენტების ჩასასმელად უნდა გამოვიყენო insert() მეთოდი მაგ:
# insert() მეთოდი ათავსებს ელემენტს მითითებულ ინდექსზე მაგ:

thislist = ["apple", "banana", "cherry",]
thislist.insert(1, "orange")
print(thislist)


# სიის გაფართოება
# სხვა სიიდან მიმდინარე სიაში ელემენტების დასამატებლად უნდა გამოვიყენო extend() მეთოდი მაგ:

thislist = ["apple", "banana", "cherry"]

tropical = ["mango", "pineapple", "papaya"]

thislist.extend(tropical)
print(thislist)

# დამატებული ელემენტი დამატებული იქნება სიის ბოლოში 


# ნებისმიერი Iterable - ს დამატება
# Extend() მეთოდს არ სჭირდება სიების დამატება შემიძლია დავამატო ნებისმიერი iterable ობიექტი (ტუპლი სეტი ლექსიკონები და ა.შ.) მაგ;

thislist = ["apple", "banana", "cherry"]

thistuple = ("kiwi", "orange")

thislist.extend(thistuple)
print(thislist)


# Pyhton - სიის ელემენტების წაშლა
# იმისთვის რო სიის ელემენტი წავშალო უნდა გამოვიყენო remove() მეთოდი მაგ:

thislist = ["apple", "banana", "cherry"]
thislist.remove("banana")
print(thislist)


# მითითებული ინდექსის წაშლა
# იმისთვის რო მითითებული ინდექსი წავშალო უნდა გამოვიყენო pop() მეთოდი მაგ:

thislist = ["apple", "banana"]
thislist.pop(1)
print(thislist)


# თუ ინდექსს არ მიუთითებ pop() მეთოდ  ავრომატურად წაშლის ბოლო ელემენტს მაგ:

thislist = ["apple", "banana", "cherry"]
thislist.pop()
print(thislist)


# del საკვანძო სიტყვა ასევე შლის მითითებულ ინდექსს მაგ:

thislist = ["apple", "banana", "cherry"]
del thislist[0]
print(thislist)


# del საკვანძო სიტყვას ასევე შეუძლია მთლიანი სიის წაშლა მაგ:

thislist = ["apple", "banana", "cherry"]
del thislist


# სიის გასუფთავება
# clear() მეთოდი ასუფთავებს სიას მაგ:
# სია კვლავ რჩება მაგრამ მას არ აქვს შინაარსი მაგ:

thislist = ["apple", "banana", "cherry"]
thislist.clear()
print(thislist)


# Python - Loop Lists
# შემიძლია "გადავხედო" სიის ელემენტეს for loop - ის გამოყენებით მაგ:

thislist = ["apple", "banana", "cherry"]
for x in thislist:
  print(x)


# ინდექსის ნომრებზე გადახედვა 
# შემიძლია გადავხედო მათი ინდექსების ნომრის მითითებით
# უნდა გამოვიყენო range() და len() ფუნქცია მაგ:

thislist = ["apple", "banana", "cherry"]
for i in range(len(thislist)):
  print(thislist[i])

# ზემოთ მოცემულ მაგალითში შექმნილი იტერაბლი არის [0, 1, 2]


# While loop - ის გამოყენება
# შემიძლია გადავხედო სიის ელემენტებს While loop - ის გამოყენებით
# ყოველი გამეორების შემდეგ უნდა გავზარდო ინდექსი 1-ით მაგ:

thislist = ["apple", "banana", "cherry"]
i = 0
while i < len(thislist):
  print(thislist[i])
  i = i + 1


# Looping Using List Comprehension
# სიის გაგება მთავაზობს უმოკლეს სინტაქსს სიების დასაბეჭდად მაგ:

thislist = ["apple", "banana", "cherry"]
[print(a) for a in thislist]


# Pyhton - list comprehension
# სიის "გააზრება" მთვაზობს უფრო მოკლე სინტაქსს როდესაც ახალი სიის შექმნა მინდა არსებული ელემენტებზე დაყრდნობით
# მაგ:
# ხილის სიაზე დაყრდნობით მსურს ახალი სიის შექმნა რომელიც შეიცავს მხოლოდ ხილს ცვლადში ასო "a" - ში
# სიის "გააზრების" გარეშე მომიწევს დავწერო განცხადება პირობითი ტესტით შიგნით მაგ:

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = []

for x in fruits:
  if "a" in x:
    newlist.append(x)

print(newlist)

# სიის გააზრებით ეს ყველაფერი შემიძლია დავწერო ერთ ხაზზე მაგ:

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = [a for a in fruits if "a" in a]

print(newlist)


# სინტაქსი

# newlist = [expression for item in iterable if condition == True]
# დაბრუნებული მნიშვნელობა არის ახალი სია რომელიც ძველ სიას უცვლელად ტოვებს

# Condition (მდგომარეობა)
# მდგომარეობა ჰგავს ფილტრს რომელიც იღებს მხოლოდ იმ ელემენტებს რომლებიც True - ია შეფასებული მაგ:

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if x != "apple"]

print(newlist)

# პირობა if x != "apple" დააბრუნებს True - ს ყველა ელემენტისთვის გარდა "apple" რომელიც ახალ სიაში ყველა ხილს შეიცავს გარდა "apple"

# პირობა არჩევითია და შეიძლება გამოვტოვო მაგ:

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits]

print(newlist)


# Iterable (გამეორებადი)
# iterable შეიძლება იყოს ნებისმიერი iterable ობიექტი როგორიცაა სია ტუპლი სეტი და ა.შ მაგ:

newlist = [x for x in range(10)]

print(newlist)


# იგივე მაგალითი მაგრამ Condition - ით მაგ:

newlist = [x for x in range(10) if x < 3]

print(newlist)


# Expression (გამოხატულება)
# "გამოთქმა" არის მიმდინარე ელემენტი გამეორებაში მაგრამ ის ასევე არის შედეგი რომლითაც შემიძლია მანიპულირება სანამ ის დასრულდება როგორც სიის ელემენტი ახალ სიაში მაგ:

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x.upper() for x in fruits]

print(newlist)

# შემიძლია შედეგი ისე დავაყენო როგორც მინდა მაგ:

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = ['hello' for x in fruits]

print(newlist)


# გამოთქმა ასევე შეიძლება შეიცავდეს პირობებს არა როგორც ფილტრი არამედ როგორც შედეგის მანიპულირების საშუალება მაგ:

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x if x != "banana" else "orange" for x in fruits]

print(newlist)

# ზემოთ მოცემულ მაგალითში ნათქვამია: "დააბრუნე ელემენტი თუ ბანანი არ არის თუ ბანანია დააბრუნე ფორთოხალი"


# Python - Sort Lists
# სიის დალაგება ანბანის მიხედვით
# იმისთვის რო სია დავალაგო ალფანუმერულად უნდა გამოვიყენო sort() მეთოდი მაგ:

thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]

thislist.sort()

print(thislist)


# მაგ:

thislist = [100, 39, 65, 82, 23]

thislist.sort()

print(thislist)


# დახარისხება კლებადობით
# კლებადობით დასახარისხებლად უნდა გამოვიყენო საკვანძო სიტყვა reverse = True მაგ:

thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]

thislist.sort(reverse = True)

print(thislist)


# მაგ:

thislist = [100, 39, 65, 82, 23]

thislist.sort(reverse = True)

print(thislist)


# sort() ფუნქციის შეცვლა
# იმისთვის რო ფუნქცია დავაკონფიგურირო უნდა გამოვიყენო საკვანძო სიტყვა key = function
# ფუნქცია დააბრუნებს რიცხვ, რომელიც გამოყენებული იქნება სიის დასალაგებლად (პირველი ყველაზე დაბალი რიცხვი) მაგ:

def myfunc(n):
  return abs(n - 39)

thislist = [100, 50, 65, 82, 23]

thislist.sort(key = myfunc)

print(thislist)


# Case Insensitive Sort
# ნაგულისხმევად sort() მეთოდი არის "უგრძნობი" რის შედეგადაც ყველა დიდი ასო დალაგებულია პატარა ასოების წინ მაგ:

thislist = ["banana", "Orange", "Kiwi", "cherry"]

thislist.sort()

print(thislist)

# საბედნიეროდ შემიძლია გამოვიყენო ჩაშენებული ფუნქციები როგორც ძირითადი ფუნქციები სიის დახარისხებისას 
# ასე რომ თუ მინდა case-insensitive sort ფუნქცია რომელიც არ არის მგრძნობიარე უნდა გამოვიყენო str.lower როგორც ძირითადი ფუნქცია მაგ:

thislist = [100, 39, 65, 82, 23]

thislist.sort()

print(thislist)


# Reverse Order
# რა მოხდება თუ მსურს შეცვალოთ სიის თანმიმდევრობა ანბანის მიუხედავად?
# reverse() მეთოდი ატრიალებს სიის ელემენტებს მაგ:

thislist = ["banana", "Orange", "Kiwi", "cherry"]

thislist.reverse()

print(thislist) 


# Pyhton - სიის ასლი
# არ შემიძლია სიის კოპირება უბრალოდ list2 = list1  - ის დაწერით რადგან list2 იქნება მხოლოდ list1 - ის მითითება ხოლო list1 - ში შეტანილი ცვლილებები ავტომატურად ასევე განხორციელდება list2-ში
# იმისთვის რო სიის ასლი შევქმნა უნდა გამოვიყენო copy() მეთოდი მაგ:

thislist = ["apple", "banana", "cherry"]
mylist = thislist.copy()
print(mylist)

# ასლის შექმნის კიდევ ერთი გზაა list() მეთოდის გამოყენება მაგ:

thislist = ["apple", "banana", "cherry"]
mylist = list(thislist)
print(mylist)


# Python - სიების გაერთიანება
# ორი სიის გაერთიანება
# არსებობს რამდენიმე გზა იმისთვის რო სიები გავაერთიანო
# ერთ-ერთი ყველზე მარტივი გზაა "+" ოპერატორის გამოყენება მაგ:

list1 = ["a", "b", "c"]
list2 = [1, 2, 3]

list3 = list1 + list2
print(list3)

# ორი სიის შეერთების კიდევ ერთი გზაა ყველა ელემენტის დამატება list2 - დან list1 - ში მაგ:

list1 = ["a", "b" , "c"]
list2 = [1, 2, 3]

for x in list2:
  list1.append(x)

print(list1)

# ან შემიძლია გამოვიყენო extend() მეთოდი იმისთვის რო სიები გავაერთიანო მაგ:

list1 = ["a", "b" , "c"]
list2 = [1, 2, 3]

list1.extend(list2)
print(list1)


# Pyhton - სიის მეთოდები
# Pyhton - ს აქვს ჩაშენებული მეთოდების ნაკრები რომლის გამოყენებაც შემიძლია მაგ:

# მეთოდი                            დასახელება

# append()                           ამატებს ელემენტს სიის ბოლოში

# clear()                            შლის ყველა ელემენტს სიიდან

# copy()                             აბრუნებს სიის ასლს

# count()                            აბრუნებს ელემენტის რაოდენობას (ანუ რამდენჯერაა აღებული რაღაც ელემენტი სიაში)

# extend()                          ერთ სიას ამატებს მეორე სიას

# index()                           აბრუნებს კონკრეტული ელემენტის ინდექსს

# insert()                           ამატებს ელემენტს მითითებულ ინდექსსზე

# pop()                              შლის ელემენტს მითითებულ ინდექსსზე

# remove()                          შლის მითითებულ ელემენტს

# reverse()                          "აბრუნებს" სიას

# sort()                             ახარისხებს სიას


# Python Tuples

mytuple = ("apple", "banana", "cherry")

# ტუპლი გამოიყენება რამდენიმე ელემენტის ერთ ცვლადში შესანახად
# ტუპლი არის ერთ-ერთი მონაცემთა ტიპი Pyhton - ში რომელიც გამოიყენება მონაცემთა კოლექციების შესანახად დანარჩენი  არის სია სეტი და ლექსიკონი
# ტუპლი არის დალაგებული და უცვლელი
# ტუპლი იწერება ესე "()" მაგ:

thistuple = ("apple", "banana", "cherry")
print(thistuple)


# ტუპლის ელემენტები
# ტუპლის ელემენტები დალაგებულია არაცვალებადი და ნებადართულია დუპლიკატები
# ტუპლის ელემენტები ინდექსირებულია მაგ: პირველ ელემენტს აქვს ინდექსი 0 მეორე ელემენტს ინდექსი 1 და ა.შ


# დალაგებული
# როდესაც ვამბობ რო ტუპლი დალაგებულია ეს ნიშნავს რო ელემენტებს აქვთ განსაზღვრული რიგი და ეს თანმიმდევრობა არ შეიცვლება


# არაცვალებადი
# ტუპლი უცვლელია რაც იმას ნიშნავს რო არ შემიძლია შევცვალო დავამატო ან წავშალო ელემენტი ტუპლის შექმნის შემდეგ


# დუპლიკატების დაშვება
# ვინაიდან ტუპლი ინდექსირებულია ეემენტებს შეიძლება ერთი და იგივე მნიშვნელობა ქონდეს მაგ:

thistuple = ("apple", "banana", "cherry", "apple", "cherry")
print(thistuple)


# ტუპლის სიგრძე
# იმისთვის რო გავიგო რამდენი ელემენტია ტუპლში უნდა გამოვიყენო len() ფუნქცია მაგ:

thistuple = ("apple", "banana", "cherry")
print(len(thistuple))

# ტუპლის შექმნა ერთი ელემენტით
# იმისათვის რო შევქმნა ტუპლი მხოლოდ ერთი ელემენტით უნდა დავამატო მძიმე ელემენტის შემდეგ თორე Pyhton - ი აღიქვავს როგორ სიას მაგ:

thistuple = ("apple",)
print(type(thistuple))

# არ არის ტუპლი

thistuple = ("apple")
print(type(thistuple))


# ტუპლის ელემენტები მონაცემთა ტიპები
# ტუპლილ ელემენტი შეიძლება იყოს ნებისმიერი მონაცემთა ტიპის მაგ:

tuple1 = ("apple", "banana", "cherry")
tuple2 = (1, 5, 7, 9, 3)
tuple3 = (True, False, False)

print(tuple1)
print(tuple2)
print(tuple3)

# ტუპლი შეიძლება შეიცავდეს მონაცემთა სხვადასხვა ტიპებს მაგ:

tuple1 = ("abc", 34, True, 40, "male")

print(tuple1)


# type()
# Pyhton - ის პერსპექტივიდან ტუპლის განისაზღვრება როგორც ობიექტები მონაცემთა ტიპის 'tuple': <class 'tuple'> მაგ:

mytuple = ("apple", "banana", "cherry")

print(type(mytuple))

# tuple() კონსტრუქტორი
# იმისთვის რო ტუპლი შევქმნა უნდა გამოვიყენო tuple() კონსტრუქტორი მაგ:

thistuple = tuple(("apple", "banana", "cherry")) # note the double round-brackets
print(thistuple)

# ტუპლი არის კოლექცია არის დალაგებული არაცვალებადი და ნებადართულია


# Pyhton - წვდომა ტუპლის ელემენტებზე
# იმისთვის რო წვდომა მოვახდინო ტუპლის ელემენტებზე უნდა მიუთითო ელემენტის ინდექსი

thistuple = ("apple", "banana", "cherry", "pineapple", "blueberry", "pinguin", "beki", "peanut")
print(thistuple[3])

# პირველ ელემენტს აქვს ინდექსი 0


# ნეგატიური ინდექსირება
# ნეგატიური ინდექსირება ნიშნავს ბოლოდან დაწყებას
# -1 შეესაბამება ბოლო ელემენტს -2 შეესაბამება ბოლოს წინა ელემენტს ა.შ მაგ:

thistuple = ("apple", "banana", "cherry", "pineapple", "blueberry", "pinguin", "beki", "peanut")
print(thistuple[-3])


# ინდექსის სიგრძე
# შემიძლია მიუთითო ინდექსების სიგრძე იმის მითითებით თუ სად უნდა დაიწყოს და სად დასრულდეს დიაპაზონი
# დიაპაზონის მითითებისას დაბრუნების მნიშვნელობა იქნება ახალი ტუპი მითითებული ელემენტებით მაგ:

thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[3:6])

# დაბეჭვდა დაიწყება ინდექსი 3 - დან (შედის) ხოლო დასრულდება ინდექს 6 - ზე (არ შედის)

# საწყისი მნიშვნელობის გამოტოვებით დაბეჭვდა დაიწყება პირველი ინდექსიდან მაგ:

thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[:3])

# საბოლოო მნიშვნელობის გამოტოვებით დაბეჭვდა გაგრძელდება ტუპლის ბოლომდე მაგ:


# ნეგატიური ინდექსების სიგრძე
# უნდა მიუთითო უარყოფითი ინდექსები თუ ძიების დაწყება ტუპლის ბოლოდან მსურს მაგ:

thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[-7:-3])


# Check if Item Exists
# იმისთვის რო გავიგო არის თუ არა გარკვეული ელემენტი ტუპლში უნდა გამოვიყენო საკვანძო სიტყვა in მაგ:

thistuple = ("apple", "banana", "cherry")
if "apple" in thistuple:
  print("Yes, 'apple' is in the fruits tuple")


# Python - Update Tuples
# ტუპლი არის არაცვალებადი რაც იმას ნიშნავს რო არ შემიძლია დავამატო ან წავშალო ელემენტები ტუპლის შექმნის შემდეგ
# მაგრამ არსებობს რამდენიმე გამოსავალი

# ტუპლის მნიშვნელობის შეცვლა
# ტუპლის შექმნის შემდეგ აღარ შემეძლება მნიშვნელობების შეცვლა
# შემიძლია დავაკონვერტირო ტუპლი გადავიყვანო სიაში შევცვალო პარამეტები და ისევ დავარბუნო ტუპლად მაგ:

a = ("apple", "banana", "cherry")
y = list(a)
y[1] = "kiwi"
a = tuple(y)

print(a)


# ელემენტების დამატება
# მას შემდეგ რაც ტუპლი უცვლელია მათ არ აქვთ ჩაშენებული append() მეთოდი მაგრამ არსებობს სხვა გზები რომ დავამატო ელემენტები ტუპლში
# 1. სიად გადაქცევა სიად გადაქცევის შემდეგ შემიძლია დავამატო ან წავშალო ელემენტები და შემდეგ ისევ დავაბრუნო ტუპლის სახით მაგ:

thistuple = ("apple", "banana", "cherry")
y = list(thistuple)
y.append("orange")
thistuple = tuple(y)

# ტუპლის დამატება ტუპლში მაგ:

thistuple = ("apple", "banana", "cherry")
y = ("orange",)
thistuple += y

print(thistuple)

# ტუპლის ერთი ელემენტით შექმნისას უნდა მახსოვდეს რო ელემენტის შემდეგ უნდა დავსვა "," სხვა შემთხვევაში Pyhton - ი აღიქვავს როგორ სია


# ელემენტების წაშლა
# ტოპები უცვლელია ასე რომ არ შემიძლია მისგან ელემენტის ამოღება მაგრამ შემიძლია გამოიყენო იგივე გამოსავალი როგორც ვიყენებდი ელემენტის შეცვლის და დამატების დროს მაგ:

thistuple = ("apple", "banana", "cherry")
a = list(thistuple)
a.remove("apple")
thistuple = tuple(a)

# ან მთლიანად ტუპლის წაშლა შემიძლია მაგ:

#thistuple = ("apple", "banana", "cherry")
#del thistuple
#print(thistuple) # Pyhton - ი დაბეჭდავს error - ს


# Python - Unpack Tuples
# როდესაც ვქმნი ტუპლს ჩვეულებრივ ვანიჭებ მას მნიშვნელობებს ამას ჰქვია ტუპლის „შეფუთვა“ მაგ:

fruits = ("apple", "banana", "cherry")

print(fruits)

# მაგრამ Pyhton - ში ასევე მაქვს ნებადართული მნიშვნელობების უკან გამოყვანა ცვლადებში ამას ჰქვია "განყუთვა" მაგ:

fruits = ("apple", "banana", "cherry")

(green, yellow, red) = fruits

print(green)
print(yellow)
print(red)

# ცვლადების რაოდენობა უნდა შეესაბამებოდეს მნიშვნელობების რაოდენობასს სხვა შემტხვევაში უნდა გამოვიყენო "*" დარჩენილი მნიშვნელობების სიის სახით შესაგროვებლად


# Asterisk - ის გამოყენება
# თუ ცვლადების რაოდენობა მნიშვნელობებზე ნაკლებია შემიძლია დავამატო "*" ცვლადის სახელს და მნიშვნელობები მიენიჭება ცვლადს როგორც სია მაგ:

fruits = ("apple", "banana", "cherry", "strawberry", "raspberry")

(green, yellow, *red) = fruits

print(green)
print(yellow)
print(red)

# თუ ვარსკვლავი დაემატება ცვლადის სხვა სახელს ვიდრე ბოლო Python - ი მიანიჭებს მნიშვნელობებს ცვლადს მანამ სანამ დარჩენილი მნიშვნელობების რაოდენობა დაემთხვევა დარჩენილი ცვლადების რაოდენობას მაგ:

fruits = ("apple", "mango", "papaya", "pineapple", "cherry")

(green, *tropic, red) = fruits

print(green)
print(tropic)
print(red)


# Python - Loop Tuples
# იმისთვის რო ტუპლს "გადავხედო" უნდა გამოვიყენო for loop - ი მაგ:

thistuple = ("apple", "banana", "cherry")
for a in thistuple:
  print(a)


# ინდექსის ნომერზე "გადახედვა"
# ასევე შემიძლია გადავამოწმო რამდენიმე ელემენტი მათი ინდექსის ნომრის მითითებით
# უნდა გამოვიყენო range() და len() ფუნქციები შესაბამისი გამეორების შესაქმნელად მაგ:

thistuple = ("apple", "banana", "cherry")
for a in range(len(thistuple)):
  print(thistuple[a])


# While loop - ის გამოყენება
# შემიძლია გადავამოწმო რამდენიმე ელემენტი While loop - ის გამოყენებით მაგ:
# უნდა გამოვიყენო len() ფუნქცია ტუპლის სიგრძის გასაგებად და შემდეგ უნდა დავიწყო 0 - დან დაბეჭვდა
# ყოველი გამეორების შემდეგ უნდა გავზარდო ინდექსი 1 - ით მაგ:

thistuple = ("apple", "banana", "cherry")
i = 0
while i < len(thistuple):
  print(thistuple[i])
  i = i + 1


# Pyhton - ტუპლების გაერთიანება
# იმისთვის რო ორი ტუპლი გავაერთიანო შემიძლია გამოვიყენო "+" ოპერატორი მაგ:

tuple1 = ("a", "b" , "c")
tuple2 = (1, 2, 3)

tuple3 = tuple1 + tuple2
print(tuple3)


# ტუპლების გამრავლება
# იმისთვის რო ტუპლები ერთმანეთზე გავამრავლო უნდა გმაოვიყენო "*" ოპერატორი მაგ:

fruits = ("apple", "banana", "cherry")
mytuple = fruits * 2

print(mytuple)


# Python - ტუპლის მეთოდები
# Pyhton - ს აქვს ორი ჩაშენებული ფუნქცია რომლის გამოყენებაც შემიძლია ტუპლებზე მაგ:

# მეთოდი                           დასახელება

#  count()                          აბრუნებს მითითებული ელემენტის აღების მნიშვნელობას ტუპლში (ანუ რამდენჯერაა აღებული მითითებული ელემენტი ტუპლში)

#  index()                           ტუპლში ეძებს მითითებულ მნიშვნელობას და აბრუნებს იმ ადგილს სადაც ეს მნიშვნელობაა


# Python სეტები

myset = {"apple", "banana", "cherry"}

# ნაკრები გამოიყენება რამდენიმე ელემენტის ერთ ცვლადში შესანახად
# სეტი არის ერთ-ერთი მონაცემთა ტიპი Pyhton - ში რომელიც გამოიყენება მონაცემთა კოლექციების შესანახად დანარჩენი სამი არის სია ტუპლი და ლექსიკონი 
# სეტი არის კოლექცია არის დაულაგებელი არაცვალებადი და არაინდექსირებული
# ნაკრების ელემენტები უცვლელია მაგრამ შემიძლია წავშალო ელემენტები და დავამატო ახალი ელემენტები

# სეტი იწერება ესე {} მაგ:

thisset = {"apple", "banana", "cherry"}
print(thisset)

# სეტი დაულაგებელია ასე ვერ გავიგებ თუ რა თანმიმდევრობით დაიბეჭდება ელემენტები


# სეტის ელემენტები
# სეტის ელემენტები დაულაგებელია არაცვალებადი და ნებადართული არ არის დუპლიკატები


# დაულაგებელი
# დაულაგებელი ნიშნავს რო სეტში არსებულ ელემენტებს არ აქვთ განსაზღვრული რიგი


# არაცვალებადი
# სეტის ელემენტები უცვლელია რაც იმას ნიშნავს რო სეტის შექმნის შემდეგ ელემენტებს ვერ შევცვლი

# სეტის შექმნის შემდეგ ვერ შევცვლი ელემენტებს მაგრამ შემიძლია წავშალო ან დავამატო ელემენტები


# დუპლიკატების არ დაშვება
# სეტს არ შეიძლება ქონდეს ორი ერთნაირი მნიშვნელობის ელემენტი მაგ:

thisset = {"apple", "banana", "cherry", "apple"}

print(thisset)


# ცვლადები True და 1 განიხილება როგორც ერთნნაირი მნიშვნელობის ელემენტები მაგ:

thisset = {"apple", "banana", "cherry", True, 1, 2}

print(thisset)


# იმისთვის რო სეტის სიგრძე გავიგო იმდა გამოვიყენო len() ფუნქცია მაგ:

thisset = {"apple", "banana", "cherry"}

print(len(thisset))


# სეტის ელემენტები - მონაცემთა ტიპები
# სეტის ელემენტი შეიძლება იყოს ნებისმიერი მონაცემთა ტიპის მაგ:

set1 = {"apple", "banana", "cherry"}
set2 = {1, 5, 7, 9, 3}
set3 = {True, False, False}

# სეტი შეიძლება შეიცავდეს მონაცემის სხვადასხვა ტიპებს მაგ:

set1 = {"abc", 34, True, 40, "male"}

print(set1)


# type()
# პითონის პერსპექტივიდან სეტები განისაზღვრება როგორც ობიექტები მონაცემთა ტიპის 'set': <class 'set'> მაგ:

myset = {"apple" , "banana", "kiwi"}


print(myset)


# set() კონსტრუქტორი
# შემიძლია გამოვიყენო set() კონსტრუქტორი იმისთვის რო სეტი შევქმნა მაგ:

thisset = set(("apple", "banana", "cherry")) # note the double round-brackets
print(thisset)

# სეტი არის კოლექცია რომელიც არის დაულაგებელი არაცვალებადი არაინდექსირებული და ნებაადართული არ არის დუპლიკატები


# Python - Access Set Items
# სეტში არ შემიძლია წვდომა ელემენტებში ინდექსის ან გასაღების მითითებით 
# მაგრამ შემიძლია სეტის ელემენტებს for loop - ის გამოყენებით "გადავხედო" მაგ:

thisset = {"apple", "banana", "cherry"}

for x in thisset:
  print(x)

# მეორე გზა

thisset = {"apple", "banana", "cherry"}

print("banana" in thisset)


# ელემენტების შეცვლა
# სეტის შექმნის შემდეგ აღარ შემეძლება ელემენტების წაშლა მაგრამ შემეძლება ელემენტების დამატება


# Pyhton - ელემენტების დამატება
# იმისთვის რო ელემენტები დავამატო უნდა გამოვიყენო add() მეთოდი მაგ:

thisset = {"apple", "banana", "cherry"}

thisset.add("orange")

print(thisset)

# სეტის დამატება
# იმისთვის რო სეტს ახალი სეტი დავუმატო უნდა გამოვიყენო update() ფუნქცია მაგ:

thisset = {"apple", "banana", "cherry"}
tropical = {"pineapple", "mango", "papaya"}

thisset.update(tropical)

print(thisset)


# Add Any Iterable
# ობიექტი update() მეთოდში შეიძლება იყოს სია ლექსიკონი სეტი და ა.შ მაგ:

thisset = {"apple", "banana", "cherry"}
mylist = ["kiwi", "orange"]

thisset.update(mylist)

print(thisset)


# Pyhton - ელემენტების წაშლა 
# იმისთვის რო ელემენტი წავშალო უნდა გამოვიყენო remove() და discard() მეთოდი მაგ:

thisset = {"apple", "banana", "cherry"}

thisset.remove("banana")

print(thisset)

# თუ remove() მეთოდი ისეთ ელემენტს მიუთითე რომელიც არ არსებობს Pyhton - ი დაბეჭდავს error - ს 

thisset = {"apple", "banana", "cherry"}

thisset.discard("banana")

print(thisset)

# თუ discard() მეთოდს იმ ელემენტზე გამოვიყენებ რომელიც არ არსებობს Pyhton - ი არ დაბეჭდავს error - ს

# ასევე შემიძლია გამოვიყენო pop() მეთოდი ელემენტის წასაშლელეად მაგრამ ეს მეთოდი წაშლის შემთხვევით ელემენტს ასე რომ ვერ ვიქნები დარწმუნებული რომელი ელემენტი წაიშლება   
# pop() მეთოდის დაბრუნებული მნიშვნელობა არის წაშლილი ელემენტი

thisset = {"apple", "banana", "cherry"}

x = thisset.pop()

print(x)

print(thisset)

# pop() მეთოდის დაბრუნებული მნიშვნელობა არის ამოღებული ელემენტი მაგ:

thisset = {"apple", "banana", "cherry"}

thisset.clear()

print(thisset)


# del საკვანძო სიტყვის გამოყენება

#thisset = {"apple", "banana", "cherry"}

#del thisset

#print(thisset)


# Pyhton - სეტებზე "გადახედვა"
# იმისთვის რო სეტის ელემენტებს "გადავხედო" უნდა გამოვიყენო for loop - ი მაგ:

thisset = {"apple", "banana", "cherry"}

for x in thisset:
  print(x)


# Pyhton - სეტების გაერთიანება
# ორი სეტის გაერთიანება
# არსებობს რამდენიმე გზა იმისთვის რო ორი სეტი გავაერთიანო
# შემიძლია გამოვიყენო union() მეთოდი რომელიც აბრუნებს ახალ სეტს რომელიც შეიცავს ყველა ელემენტს ორივე სეტიდან ან update() მეთოდი რომელიც ჩასვამს ყველა ელემენტს ერთი სეტიდან მეორეში მაგ:

set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}

set3 = set1.union(set2)
print(set3)

# union() მეთოდი აბრუნებს ახალ სეტს ორივე სეტის ელემენტებით
# update() მეთოდი აბრუნებს ერთ-ერთ სეტს რომელსაც მიებმევა მაგ:

set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}

set1.update(set2)
print(set1)


# სეტის მეთოდები
# Pyhton - ს აქვს ჩაშენებული მეთოდწების ნაკრები რომელიც შემიძლია გამოვიყენო სეტში

# მეთოდი                                                     დასახელება

# add()                                                       ამატებს ელემენტს სეტში

# clear()                                                      შლის ელემენტს სეტიდან

# copy()                                                       აბრუნებს სეტის ასლს

# difference()                                                აბრუნებს სეტს რომელიც შეიცავს განსხვავებას სამ ან მეტ კომპლექტს შორის 

# difference_update()                                          შლის სეტის ელემენტებს რომლებიც ასევე შედის სხვა მითითებულ სეტში

# discard()                                                     შლის მითითებულ ელემენტს

# intersection()                                                 აბრუნებს სეტს რომელიც არის ორი სეტის გადაკვეთა

# intersection_update()                                         შლის ამ ნაკრების ელემენტებს რომლებიც არ არის სხვა მითითებულ კომპლექტ(ებ)ში

# isdisjoint()                                                  აბრუნებს ორ კომპლექტს აქვს თუ არა გადაკვეთა

# issubset()                                                     აბრუნებს შეიცავს თუ არა ამ კომპლექტს სხვა ნაკრები

# issuperset()                                                   აბრუნებს, შეიცავს თუ არა ეს ნაკრები სხვა კომპლექტს

# pop()                                                           ამოიღებს ელემენტს ნაკრებიდან

# remove()                                                         შლის მითითებულ ელემენტს

# symmetric_difference()                                           აბრუნებს სიმრავლეს ორი სიმრავლის გამოყენებით

# symmetric_difference_difference()                               აყენებს სიმეტრიულ განსხვავებებს ამ და სხვა ნაკრებებისგან

# union()                                                           დააბრუნებს ნაკრებს რომელიც შეიცავს სეტების გაერთიანებას 

# update()                                                            ერთ სეტს აბავს მეორე სეტს 


# Pyhton - ლექსიკონი

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# ლექსიკონები გამოიყენება მონაცემთა მნიშვნელობების შესანახად key:value წყვილებში
# ლექსიკონი არის კოლექცია რომელიც არის დალაგებული ცვალებადი და ნებადართული არ არის დუპლიკატები
# ლექსიკონები იწერება ფიგურული ფრჩხილებით მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(thisdict)


# ლექსიკონის ელემენრტები
# ლექსიკონის ელემენტები არის დალაგებული ცვალებადი და ნებადართული არ არის დუპლიკატები
# ლექსიკონის ელემენტები წარმოდგენილია key:value წყვილის სახით მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(thisdict["brand"])


# დალაგებული თუ დაულაგებელი ?
# როდესაც ვამბობ რო ლექსიკონი დალაგებულია ეს ნიშნიშნავს რო ელეემენტებს აქვთ განსაზღვრული თანმიმდევრობა
# დაულაგებელი ნიშნავს რო ელემენტებს არ აქვთ განსაზღვრული რიგი ამიტომ არ შემიძლია ელემენტებს შეუსაბამო ინდექსი


# ცვალებადი
# ლექსიკონი ცვალებადია ეს იმას ნიშნავს რო შემიძკლია შევცვალო დავამატო ან წავშალო ელემენტები ლექსიკონის შექმნის შემდეგ


# დუპლიკატების არ დაშვება
# ლექსიკონს არ შეიძლება ქონდეს ორი ელემენტი ერთი და იგივე ელემენტით მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "year": 2020
}
print(thisdict)


# ლექსიკონის სიგრძე
# იმისთვის რო ლექსიკონის სიგრძე გავიგო უნდა გამოვიყენო len() ფუნქცია მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "year": 2020
}
print(len(thisdict))

# ლექსიკონის ელემენტები მონაცემთა მონაცემთა ტიპები
# ცვლადები ლექსიკონში შეიძლება იყოს ნებისმიერი მონაცემთა ტიპის მაგ:

thisdict = {
  "brand": "Ford",
  "electric": False,
  "year": 1964,
  "colors": ["red", "white", "blue"]
}

print(thisdict)

# type()
# Pyhton - ის პერსპექტივიდან ლექსიკონი განისაზღვრება როგორც ობიექტები რომლებსაც აქვთ მონაცემთა ტიპი "dict": <class 'dict'>

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(type(thisdict))


# dict() კონსტრუქტორი
# ლექსიკონი შევქმნა უნდა გამოვიყენო dict() კონსტრუქტორი მაგ:

thisdict = dict(name = "John", age = 36, country = "Norway")

print(thisdict) 

# ლექსიკონი არის კოლექცია რომელიც არის დალაგებული ცვალებადი და ნებადართული არ არის დუპლიკლატები


# Pyhton - წვდომა ლექსიკონის ელემენტებზე
# ლექსიკონის ელემენტებზე წვდომისთვის ფიგურულ ბრჭყალებში უნდა მიუთითო ამ ელემენტის შესაბამისი "key" მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
x = thisdict["model"]
print(x)

# არსებობს მეთოდი get() რომელიც იგივეს დაბეჭდავს მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
x = thisdict.get("model")
print(x)


# გასაღების (key) მიღება
# keys() მეთოდი დააბრუნებს ლექსიკონის ყველა key - ს ჩამონათვალს მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

x = thisdict.keys()

print(x)

# გასაღებების სია არის ლექსიკონის ხედი რაც ნიშნავს რო ლექსიკონში შესრულებული ნებისმიერი ცვლილება აისახება გასაღებების სიაში მაგ:

car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.keys()

print(x) # შეცვლა

car["color"] = "white"

print(x) # შეცვლის შემდეგ

# Get Values
# values() მეთოდი დააბრუნებს ლექსიკონში არსებული ყველა მნიშვნელობის ჩამონათვალს მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

x = thisdict.values()

print(x)

# მნიშვნელობების სია არის ლექსიკონის ხედი რაც ნიშნავს რო ლექსიკონში განხორციელებული ნებისმიერი ცვლილება აისახება მნიშვნელობების სიაში მაგ:

car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.values()

print(x) # შეცვლა

car["year"] = 2020

print(x) # შეცვლის შემდეგ


# ელემენტების მოპოვება
# Item() მეთოდი დააბრუნებს თითოეულ ელემენტს ლექსიკონში ტუპლის სახით მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

x = thisdict.items()

print(x)

# დაბრუნებული სია არის ლექსიკონის ელემენტების ხედი რაც ნიშნავ, რო ლექსიკონში შეტანილი ნებისმიერი ცვლილება აისახება ერთეულების სიაში მაგ:

car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.items()

print(x) # შეცვლა

car["year"] = 2020

print(x) 


# Check if Key Exists
# იმისთვის რო გავიგო არის თუ არა გარკვეული გასაღები ლექსიკონში უნდა გამოვიყენო საკვანძო სიტყვა in მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
if "model" in thisdict:
  print("Yes, 'model' is one of the keys in the thisdict dictionary")


# Pyhton - ლექსიკონის ელემენტების შეცვლა
# ელემენტის შეცვლა შემიძლია მისი გასაღების სახელის მითითებით მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

thisdict["year"] = 2018

print(thisdict)


# Update Dictionary
# update() მეთოდი განაახლებს ლექსიკონს მოცემული არგუმენტის ელემენტებით
# არგუმენტი უნდა იყოს ლექსიკონი ან გამეორებადი ობიექტი key:value წყვილებით მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.update({"year": 2020})

print(thisdict)


# Python - Add Dictionary Items
# ლექსიკონში ელემენტის დამატება ხდება ახალი ინდექსის გასაღების გამოყენებით და მისთვის მნიშვნელობის მინიჭებით მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict["color"] = "red"
print(thisdict)


# Update Dictionary
# update() მეთოდი განაახლებს ლექსიკონს მოცემული არგუმენტის ელემენტებით თუ ელემენტი არ არსებობს ელემენტი დაემატება
# არგუმენტი უნდა იყოს ლექსიკონი, ან გამეორებადი ობიექტი key:value წყვილებით მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.update({"color": "red"})

print(thisdict)


# Python - Remove Dictionary Items
# ლექსიკონიდან ელემენტების წაშლის რამდენიმე გზა არსებობს მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.pop("model")
print(thisdict)

# popitem() მეთოდი წაშლის ბოლო ელემენტს მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.popitem()
print(thisdict)

# del საკვანძო სიტყვა წაშლის key:value წყვილს მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
del thisdict["model"]
print(thisdict)

# del საკვანძო სიტყვას შეუძლია წაშალოს მთლიანი ლექსიკონი მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
#del thisdict
#print(thisdict)

# clear() მეთოდი ასუფთავებს ლექსიკონს მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.clear()
print(thisdict)


# Python - Loop Dictionaries
# იმისთვის რო ლექსიკონს გადავხედო უდნა გამოვიყენო foრ loop - ი
# ლექსიკონის დაბრუნებისას დაბრუნების მნიშვნელობა არის ლექსიკონის გასაღები მაგრამ არსებობს მნიშვნელობების დაბრუნების მეთოდებიც მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
for x in thisdict:
  print(x)


# მეორე მაგალითი

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
for x in thisdict:
  print(thisdict[x])

# value() მეთოდი დააბრუნებს ლექსიკონის ცვლადებს მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
for x in thisdict.values():
  print(x)

# keys() მეთოდი დააბრუნებს ლექსიკონის გასაღებებს მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
for x in thisdict.keys():
  print(x)

# იმისთვის რო ლექსიკონს გასაღებებს და მნიშვნელობებეს გადავხედო უნდა გამოვიყენო item() მეთოდი მაგ:

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
for x, y in thisdict.items():
  print(x, y)


# Pyhton - ლექსიკონების ასლი
# არ შემიძლია ლექსიკონის კოპირება უბრალოდ dict1 = dict2 აკრეფით რადგან dict2 იქნება მხოლოდ მითითება dict1-ზე და dict1-ში შეტანილი ცვლილებები ავტომატურად განხორციელდება dict2 - შიც
# იმისთვის რო ლექსიკონის ასლი შევქმნა უნდა გამოვიყენო copy() მეთოდი მაგ:

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
mydict = thisdict.copy()
print(mydict)

# ასლის შექმნის კიდევ ერთი გზაა ჩაშენებული ფუნქციის dict()

thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
mydict = dict(thisdict)
print(mydict)


# Pyhton - დდაბუდული ლექსიკონები
# ლექსიკონში შეიძლება ჩავწერო ლექსიკონი ამ კი დაბუდული ლექსიკონი ქვი

myfamily = {
  "child1" : {
    "name" : "Emil",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  },
  "child3" : {
    "name" : "Linus",
    "year" : 2011
  }
}

print(myfamily)

# თუ მინდა რო დავამატო სამი ლექსიკონი ახალ ლექსიკონში მაგ:

child1 = {
  "name" : "Emil",
  "year" : 2004
}
child2 = {
  "name" : "Tobias",
  "year" : 2007
}
child3 = {
  "name" : "Linus",
  "year" : 2011
}

myfamily = {
  "child1" : child1,
  "child2" : child2,
  "child3" : child3
}

print(myfamily)

# დაბუდული ლექსიკონიდან ერთეულებზე წვდომისთვის უნდა გამოვიყენო ლექსიკონების სახლი დაწყებული გარე ლექსიკონიდან მაგ:

myfamily = {
  "child1" : {
    "name" : "Emil",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  },
  "child3" : {
    "name" : "Linus",
    "year" : 2011
  }
}

print(myfamily["child2"]["name"])

# Pyhton - ლექსიკონების მეთოდები
# Pyhton - ს აქვს ჩაშენებული მეთოდები რომლის გამოყენებაც შემიძლია 

# მეთოდი                                     დასახელება

# clear()                                     შლის ყველა ელემენნტს ლექსიკონიდან

# copy()                                      აბრუნებს სიის ასლს

# fromkeys()                                  აბრუნებს გასაღებს მითითებული გასაღრებით და მნშვნელობი

# keys()                                      აბრუნებს შესაბამისი გასაღების მნიშვნელობას

# pop()                                       წაშლის ელემენტს მითითებული გასაღებით

# popitem()                                    წაშლის ბოლოს დაწერლ key:value წყვილს

# setdefault()                                 აბრუნებს შესაბამისი გასაღების მნიშვნელობას თუ გასაღები არ არსებობს მაშინ უდნა ჩავსვა გასაღები მითითებული მნიშვნელობით

# update()                                     აახლებს ლექსიკონს მითითებული key:value წყვილებით

# values()                                     აბრუნებს ცვლადების სიას ლექსიკონში


# Python If ... Else
# Pyhton - განცხადებები და if განცხადებები

# Pyhton მხარს უჭერს ჩვეულებრივ ლოგიკურ პირობებს მათემატიკიდან მაგ:

# Equals: a == b

# Not Equals: a != b

# Less than: a < b

# Less than or equal to: a <= b

# Greater than: a > b

# Greater than or equal to: a >= b

# ეს პირობები შეიძლება გამოყენებულ იქნას რამდენიმე გზით ყველაზე ხშირად "if განცხადებებში" და loop - ბში
# if განცხადება იწერება if საკვანძო სიტყვის გამოყენებით მაგ:

a = 33
b = 200

if b > a:
  print("b is greater than a")


# ამ მაგალითში ვიყენებ ორ ცვლადს a და b რომლებიც გამოიყენება if განაცხადის ნაწილად რათა შევამოწმო არის თუ არა b მეტი a - ზე რადგან a არის 33 და b არის 200 ვინაიდან ვიცი რო 200 მეტია 33-ზე და ამიტომ ვბეჭდავ ეკრანზე რო "b მეტია a - ზე"

# ჩაღრმავება
# Pyhton - ი ეყრდნობა ჩაღრმავებას კოდში არეალის განსაზღვრისათვის სხვა პროგრამირების ენები ხშირად იყენებენ ხვეულ ფრჩხილებს ამ მიზნით მაგ:

#a = 33
#b = 200

#if b > a:
#print("b is greater than a") # Pyhton - დაბეჭდაბვს error - ს


# Elif
# elif - ის საკვანძო სიტყვა არის პითონის გზა რომ თქვას "თუ წინა პირობები არ იყო ჭეშმარიტი მაშინ სცადე ეს პირობა" მაგ:

a = 33
b = 33
if b > a:
  print("b is greater than a")
elif a == b:
  print("a and b are equal")

# ამ მაგალითში a უდრის b ასე რომ პირველი პირობა არ არის ჭეშმარიტი მაგრამ elif პირობა არის true ამიტომ ვბეჭდავ ეკრანზე რომ "a და b ტოლია" 

# Else
# else საკვანძო სიტყვა იჭერს ყველაფერს რაც არ არის დაჭერილი წინა პირობებისგან მაგ:

a = 200
b = 33
if b > a:
  print("b is greater than a")
elif a == b:
  print("a and b are equal")
else:
  print("a is greater than b")

# ამ მაგალითში a მეტია b - ზე ამიტომ პირველი პირობა არ არის ჭეშმარიტი ასევე elif პირობა არ არის ჭეშმარიტი ასე რომ გადავდივარ სხვა პირობაზე და ვბეჭდავ ეკრანზე რომ "a მეტია b - ზე"
# ასევე შემიძლია მხოლოდ else პირობა გამოვიყენო და არა elif 

a = 200
b = 33
if b > a:
  print("b is greater than a")
else:
  print("b is not greater than a")


# Short Hand If
# თუ მხოლოდ ერთი განაცხადი მაქვს შესასრულებელი შემიძლია განვათავსო იგი იმავე ხაზზე როგორც if ინსტრუქცია

a = 200
b = 33

if a > b: print("a is greater than b")


# Short Hand If ... Else
# თუ მაქვს მხოლოდ ერთი განცხადება შესასრულებელი ერთი if და ერთი else შემიძლია ეს ყველაფერი იმავე ხაზზე განვათავსო მაგ:

a = 2
b = 330

print("A") if a > b else print("B")

# ეს ტექნიკა ცნობილია როგორც მესამეული ოპერატორები ან პირობითი გამონათქვამები
# ასევე შემიძლია მქონდეს მრავალი სხვა განცხადება იმავე ხაზზე მაგ:

a = 330
b = 330

print("A") if a > b else print("=") if a == b else print("B")


# And
# და საკვანძო სიტყვა არის ლოგიკური ოპერატორი და გამოიყენება პირობითი განცხადებების გაერთიანებისთვის:

a = 200
b = 33
c = 500
if a > b and c > a:
  print("Both conditions are True")


# or
# ან საკვანძო სიტყვა არის ლოგიკური ოპერატორი და გამოიყენება პირობითი განცხადებების გაერთიანებისთვის მაგ:

a = 200
b = 33
c = 500
if a > b or a > c:
  print("At least one of the conditions is True")


# Not
# not ოპერატორი არის ლოგიკური ოპერატორი რომელიც გამოიყენება შედეგის შესატრიალებლად მაგ:

a = 33
b = 200
if not a > b:
  print("a is NOT greater than b")


# Nested If
# if განცხადებები შეიძლება მქონდეს if განცხადებების შიგნით, ამას ეწოდება ჩადგმული if განცხადებები.

x = 41

if x > 10:
  print("Above ten,")
  if x > 20:
    print("and also above 20!")
  else:
    print("but not above 20.")


# The pass განცხადება
# if განცხადებები არ შეიძლება იყოს ცარიელი მაგრამ თუ რაიმე მიზეზით მაქვს if განცხადება შინაარსის გარეშე შეცდომის თავიდან ასაცილებლად უდნა დავწერო pass განცხადება

a = 33
b = 200

if b > a:
  pass 


# Pyhton - while loop
# Pyhton - ს აქვს ორი პრიმიტიული მარყუჟის ბრძანება მაგ:

# while loop
# for loop


# The while Loop
# while მარყუჟით შემიძლია შევასრულო განცხადებების ნაკრები სანამ პირობა true - ა

i = 1
while i < 6:
  print(i)
  i += 1

# i თუ არ გაიზარდა loop - ი გაგრძელდება უსასრულობამდე
# while loop - ი მოითხოვს შესაბამისი ცვლადების მზადყოფნას ამ მაგალითში უნდა განვსაზღვრო ინდექსირების ცვლადი i რომელიც დავაყენე 1 - ზე


# The break Statement
# break განაცხადის საშუალებით შემიძლია დავასტოპო loop - ი მაშინაც კი თუ პირობა while მართალია მაგ:

i = 1
while i < 6:
  print(i)
  if (i == 3):
    break
  i += 1


# The Countinue Statement
# continue განცხადებით შემიძლია დავასტოპო გამეორება და გავაგრძელო შემდეგიდან მაგ:

i = 0
while i < 6:
  i += 1
  if i == 3:
    continue
  print(i)


# The else Statement
# else განცხადების საშუალებით შემიძლია გავუშვა კოდის ბლოკი ერთხელ როდესაც პირობა აღარ არის ჭეშმარიტი მაგ:

i = 1
while i < 6:
  print(i)
  i += 1
else:
  print("i is no longer less than 6") 


# Python While Loops
# Pyhton - ს აქვს ორი პრიმიტიული loop - ის ბრძანება მაგ:

# while loops
# for loops


# The while Loop
# while loop - ით შემიძლია შევასრულო განცხადებების ნაკრები სანამ პირობა true - ა მაგ:

i = 1
while i < 6:
  print(i)
  i += 1


# უნდა გავზარდო i წინააღმდეგ შემთხვევაში loop სამუდამოდ გაგრძელდება მაგ:
# while loop - ი მოითხოვს შესაბამისი ცვლადების მზადყოფნას ამ მაგალითში უნდა განვსაზღვრო ინდექსირების ცვლადი i რომელიც დავაყენე 1 - ზე


# The break Statement
# break განაცხადის საშუალებით შემიძლია დავასტოპო მარყუჟი მაშინაც კი თუ პირობა while მართალია მაგ:

i = 1
while i < 6:
  print(i)
  if (i == 3):
    break
  i += 1



# The continue Statement
# continue განაცხადით შემიძლია დავასტოპო მიმდინარე გამეორება და გავაგრძელოთ შემდეგი მაგ:

i = 0
while i < 6:
  i += 1
  if i == 3:
    continue
  print(i)


# The else Statement
# სხვა განცხადების საშუალებით შემიძლია გავუშვა კოდის ბლოკი ერთხელ როდესაც პირობა აღარ არის ჭეშმარიტი მაგ:

i = 1
while i < 6:
  print(i)
  i += 1
else:
  print("i is no longer less than 6")


# Python For Loops
# for loop გამოიყენება მიმდევრობით (ეს არის სია ტუპლი ლექსიკონი სეტი ან სტრიქონი) განმეორებისთვის
# ეს ნაკლებად ჰგავს for საკვანძო სიტყვას სხვა პროგრამირების ენებში და უფრო მეტად მუშაობს iterator მეთოდის მსგავსად როგორც ეს მხვდება სხვა ობიექტზე ორიენტირებულ პროგრამირების ენებში
# for loop - ის საშუალებით შემძლია შევასრულო განცხადებების ნაკრები ერთხელ თითოეული ელემენტისთვის სიაში ტუპლში სეტში და ა.შ მაგ:

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x) 

# for loop არ საჭიროებს ინდექსირების ცვლადის წინასწარ დაყენებას


# Looping Through a String
# სტრიქონებიც კი გამეორებადი ობიექტებია, ისინი შეიცავს სიმბოლოების თანმიმდევრობას მაგ:

for x in "banana":
  print(x)


# The break Statement
# break განცხადებით შემიძლია დავასტოპო ციკლი მანამ სანამ ის ყველა ელემენტს "გადახედავს" მაგ:

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  if x == "banana":
    break


fruits = ["apple", "banana", "watermelon"]
for x in fruits:
  if x == "banana":
    break
  print(x)


# The continue Statement
# continue განცხადებით შემიძლია დავასტოპო loop - ის მიმდინარე გამეორება და გავაგრძელოთ შემდეგი მაგ:

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  if x == "banana":
    continue
  print(x)


# The range() Function
# იმისთვის რო კოდის კომპლექტს გადავხედო უნდა გამოვიყენო range() ფუნქცია
# range() ფუნქცია აბრუნებს რიცხვების თანმიმდევრობას ნაგულისხმევად დაწყებული 0 - დან და იზრდება 1 - ით (ნაგულისხმევად) და მთავრდება მითითებულ რიცხვზე მაგ:

for x in range(8):
  print(x)

# უნდა გავითვალისწინო რომ დიაპაზონი (8) არ არის 0 - დან 8 - მდე არამედ 0 - დან 7 - მდე
# range() ფუნქცია ნაგულისხმევად არის 0 როგორც საწყისი მნიშვნელობა თუმცა შესაძლებელია საწყისი მნიშვნელობის მითითება პარამეტრის დამატებით: range(2, 8) რაც ნიშნავს მნიშვნელობებს 2-დან 8-მდე (მაგრამ 8-ის გარეშე) მაგ:

for x in range(2, 6):
  print(x)

# range() ფუნქციაში იგულისხმევა რო გაზარდოს თანმიმდევრობა 1-ით თუმცა შესაძლებელია გაზრდის მნიშვნელობის მითითება მესამე პარამეტრის დამატებით: range(2, 30, 3) მაგ:

for x in range(2, 30, 3):
  print(x)


# Else in for loop

for x in range(6):
  print(x)
else:
  print("Finally finished!")

# else ბლოკი არ შესრულდება თუ loop - ი დასტოპებულია break განცხადებით 

for x in range(6):
  if x == 3: break
  print(x)
else:
  print("Finally finished!")


# დაბუდული loop - ები
# "შიდა მარყუჟი" შესრულდება ერთხელ "გარე მარყუჟის" ყოველი გამეორებისთვის მაგ:

adj = ["red", "big", "tasty"]
fruits = ["apple", "banana", "cherry"]

for x in adj:
  for y in fruits:
    print(x, y)

# The pass Statement
# for loop არ შეიძლება იყოს ცარიელი მაგრამ თუ ცარიელია უნდა გამოვიყენო pass განცხადება მაგ:

for x in [0, 1, 2]:
  pass 

# Python Functions
# ფუნქცია არის კოდის ბლოკი რომელიც მუშაობს მხოლოდ მისი გამოძახებისას
# შემიძლია გადავცე მონაცემები რომლებიც ცნობილია როგორც პარამეტრები ფუნქციაში
# ფუნქციას შეუძლია მონაცემების დაბრუნების შედეგად


# Creating a Function
# პითონში ფუნქცია განისაზღვრება def საკვანძო სიტყვის გამოყენებით მაგ:

def my_function():
  print("Hello from a function")


# Calling a Function
# ფუნქციის გამოსაძახებლად უნდა გამოვიყენო ფუნქციის სახელი რასაც მოჰყვება ფრჩხილები მაგ:

def my_function():
  print("Hello from a function")

my_function()


# არგუმენტები
# ინფორმაცია შეიძლება გადავიდეს ფუნქციებში როგორც არგუმენტები
# არგუმენტები მითითებულია ფუნქციის სახელის შემდეგ ფრჩხილებში თქვენ შეგიძლიათ დაამატოთ იმდენი არგუმენტი რამდენიც გსურთ უბრალოდ გამოყავით ისინი მძიმით
# შემდეგ მაგალითს აქვს ფუნქცია ერთი არგუმენტით (fname) როდესაც ფუნქცია გამოიძახება გადავცემ სახელს რომელიც გამოიყენება ფუნქციის შიგნით სრული სახელის დასაბეჭდად მაგ:

def my_function(fname):
  print(fname + " Refsnes")

my_function("Emil")
my_function("Tobias")
my_function("Linus")

# Pyhton - ის დოკუმენტაციაში არგუმენტები (arguments) ხშირად მცირდება არგუმენტებად (args) - ად


# Parameters or Arguments?
# ტერმინები პარამეტრი და არგუმენტი შეიძლება გამოვიყენო ერთ მნი9შვნელობად ინფორმაცია რომელიც გადაეცემა ფუნქციაში

# ფუნქციის პერსპექტივიდან:
# პარამეტრი არის ცვლადი რომელიც ჩამოთვლილია ფრჩხილებში ფუნქციის განსაზღვრაში
# არგუმენტი არის მნიშვნელობა რომელიც ეგზავნება ფუნქციას მისი გამოძახებისას


# არრგუმენტების რაოდენობა
# ნაგულისხმევად ფუნქცია უნდა იყოს გამოძახებული არგუმენტების სწორი რაოდენობით რაც იმას ნიშნავს რომ თუ ფუნქცია ელის 2 არგუმენტს უნდა გამოძახო ფუნქცია 2 არგუმენტით არც მეტი და არც ნაკლები

def my_function(fname, lname):
  print(fname + " " + lname)

my_function("Emil", "Refsnes")

# თუ ვცდილობ ფუნქციის გამოძახებას 1 ან 3 არგუმენტით მიღებ შეცდომას მაგ:

#def myfunc(fname, lname):
#  print(fname + " "+ lname)

#myfunc()


# თვითნებური არგუმენტები *args
# თუ არ ვიცი რამდენი არგუმენტი გადაეცემა თქვენს ფუნქციას უნდა დავამატო * პარამეტრის სახელამდე ფუნქციის განსაზღვრაში 
# ამ გზით ფუნქცია მიიღებს რამდენიმე არგუმენტს და შესაბამისად შეუძლია წვდომა ელემენტებზე მაგ:

def my_function(*kids):
  print("The youngest child is " + kids[2])

my_function("Emil", "Tobias", "Linus")

# თვითნებური არგუმენტები ხშირად მცირდება *args-მდე პითონის დოკუმენტაციაში


# Keyword Arguments
# ასევე შემიძლია გაგზავნო არგუმენტები გასაღები = მნიშვნელობის სინტაქსით
# ამ გზით არგუმენტების თანმიმდევრობას მნიშვნელობა არ აქვს მაგ:

def my_function(child3, child2, child1):
  print("The youngest child is " + child3)

my_function(child1 = "Emil", child2 = "Tobias", child3 = "Linus")

# Python - ის დოკუმენტაციაში ფრაზა Keyword Arguments ხშირად მცირდება kwargs - მდე 


# თვითნებური საკვანძო სიტყვების არგუმენტები **kwargs
# თუ არ ვიცი რამდენი საკვანძო სიტყვის არგუმენტი გადაეცემა ფუნქციას უნდა დავამატო ორი ვარსკვლავი: ** პარამეტრის სახელამდე ფუნქციის განსაზღვრაში
# ამ გზით ფუნქცია მიიღებს არგუმენტების ლექსიკონს და შესაბამისად შეუძლია წვდომა ერთეულებზე მაგ:

def my_function(**kid):
  print("His last name is " + kid["lname"])

my_function(fname = "Tobias", lname = "Refsnes")


# თვითნებური Kword არგუმენტები ხშირად მცირდება **kwargs - ით პითონის დოკუმენტაციაში
# პარამეტრის ნაგულისხმევი მნიშვნელობა
# შემდეგი მაგალითი აჩვენებს თუ როგორ გამოვიყენო ნაგულისხმევი პარამეტრის მნიშვნელობა
# თუ ფუნქციას არგუმენტის გარეშე გამოვიძახებ ის იყენებს ნაგულისხმევ მნიშვნელობას მაგ:

def my_function(country = "Norway"):
  print("I am from " + country)

my_function("Sweden")
my_function("India")
my_function()
my_function("Brazil")


# Passing a List as an Argument
# შემიძლია გაუგზავნოთ ნებისმიერი მონაცემთა ტიპის არგუმენტი ფუნქციას (სტრიქონი რიცხვი სია ლექსიკონი და ა.შ.) და ის განიხილება როგორც იგივე მონაცემთა ტიპი ფუნქციის შიგნით.
# მაგალითად თუ გავგზავნი სიას არგუმენტად ის დარჩება სიად როდესაც ფუნქციას მიაღწევს მაგ:

def my_function(food):
  for x in food:
    print(x)

fruits = ["apple", "banana", "cherry"]

my_function(fruits)


# Return Values
# იმისათვის რომ ფუნქციამ დააბრუნოს მნიშვნელობა გამოიყენეთ დაბრუნების განცხადება მაგ:

def my_function(x):
  return 5 * x

print(my_function(3))
print(my_function(5))
print(my_function(9))


# The pass Statement
# ფუნქციის დეფინიციები არ შეიძლება იყოს ცარიელი მაგრამ თუ რაიმე მიზეზით ფუნქციის განმარტება შინაარსის გარეშეა უნდა გამოვიყენო pass განცხადება რათა თავიდან აიცილოთ error მაგ:


def myfunction():
  pass


# Recursion
# პითონი ასევე იღებს ფუნქციის რეკურსიას რაც ნიშნავს რომ განსაზღვრულ ფუნქციას შეუძლია საკუთარი თავის გამოძახება
# რეკურსია არის საერთო მათემატიკური და პროგრამირების კონცეფცია ეს ნიშნავს რომ ფუნქცია თავის თავს იძახებს ეს იმას ნიშნავს რო შემიძლია შეასრულო მონაცემები შედეგის მისაღწევად
# დეველოპერი ძალიან ფრთხილად უნდა იყოს რეკურსიასთან რადგან შეიძლება საკმაოდ მარტივი იყოს ფუნქციის ჩაწერა რომელიც არასდროს მთავრდება ან ის რომელიც იყენებს ჭარბი რაოდენობით მეხსიერების ან პროცესორის სიმძლავრეს თუმცა როდესაც სწორად არის დაწერილი რეკურსი შეიძლება იყოს ძალიან ეფექტური და მათემატიკურად ელეგანტური მიდგომა პროგრამირებისადმი
# ამ მაგალითში tri_recursion() არის ფუნქცია რომელიც განვსაზღვრე რო თავად ვუწოდო ("recurse") ვიყენებ k ცვლადს როგორც მონაცემს რომელიც მცირდება (-1) ყოველ ჯერზე როცა განმეორებით ვაკეთებ რეკურსია მთავრდება როდესაც პირობა არ არის 0-ზე მეტი (ანუ როცა არის 0).
# ახალ დეველოპერს შეიძლება გარკვეული დრო დასჭირდეს იმის გასარკვევად თუ როგორ მუშაობს ეს,  საუკეთესო გზა ამის გასარკვევად არის მისი ტესტირება და შეცვლა მაგ:

def tri_recursion(k):
  if(k > 0):
    result = k + tri_recursion(k - 1)
    print(result)
  else:
    result = 0
  return result

print("\n\nRecursion Example Results")
tri_recursion(6)
 

# Pyhton Lambda
# ლამბდა ფუნქცია არის პატარა ანონიმური ფუნქცია.
# ლამბდა ფუნქციას შეუძლია მიიღოს ნებისმიერი რაოდენობის არგუმენტი, მაგრამ შეიძლება ჰქონდეს მხოლოდ ერთი გამოხატულება

# Syntax

# lambda arguments : expression

# გამოთქმა შესრულებულია და შედეგი დაბრუნებული:

x = lambda a : a + 10
print(x(5))

# ლამბდას ფუნქციებს შეუძლიათ მიიღონ ნებისმიერი რაოდენობის არგუმენტი:

x = lambda a, b : a * b
print(x(5, 6))


x = lambda a, b, c : a + b + c
print(x(5, 6, 2))


# Why Use Lambda Functions?
# ლამბდას სიმძლავრე უკეთესად ჩანს როდესაც ის აგმოიყენება ანონიმურ ფუნქციად სხვა ფუნქციის შიგნით
# ვთქვა რო არის ფუნქციის განმარტება რომელიც იღებს ერთ არგუმენტს და ეს არგუმენტი გამრავლდება უცნობ რიცხვზე

def myfunc(n):
  return lambda a : a * n

# უნდა გამოვიყენო ეფუნქციის ეს განმარტება იმისათვის რომ შევქმნა ფუნქცია რომელიც ყოველთვის გააორმაგებს ჩემს მიერ გაგზავნილ რიცხვს:

def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)

print(mydoubler(11))

# ან უნდა გამოვიყენ იგივე ფუნქციის განმარტება რათა შექმნათ ფუნქცია რომელიც ყოველთვის სამჯერ აჭარბებს ჩემს მიერ გაგზავნილ რიცხვს მაგ:

def myfunc(n):
  return lambda a : a * n

mytripler = myfunc(3)

print(mytripler(11))

# ან უნდა გამოიყენ იგივე ფუნქციის განმარტება ორივე ფუნქციის შესაქმნელად იმავე პროგრამაში:

def myfunc(n):
  return lambda a : a * n

mydoubler = myfunc(2)
mytripler = myfunc(3)

print(mydoubler(11))
print(mytripler(11))

# უნდა გამოვიყენლამბდა ფუნქციები როდესაც საჭიროა ანონიმური ფუნქცია მოკლე დროში 
